# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

name: Vulnerability Scanning

on:
  workflow_dispatch:
  push:
    branches: [ "main" ]
  pull_request:
    # The branches below must be a subset of the branches above
    branches: [ "main" ]
  schedule:
    - cron: '0 7 * * 1-5' # Run every weekday at 7am UTC

permissions:
  contents: read
  id-token: write # Required for AWS OIDC authentication
  security-events: write # Required for uploading SARIF results to GitHub Security tab
  actions: read # Required for private repositories to get Action run status
  pull-requests: write # Required for writing comments on pull requests

jobs:
  trivy:
    strategy:
      fail-fast: false
      matrix:
        image: [
          {dockerfile: Dockerfile, name: liquibase/liquibase, suffix: ""},
          {dockerfile: Dockerfile.alpine, name: liquibase/liquibase, suffix: "-alpine"},
          {dockerfile: DockerfileSecure, name: liquibase/liquibase-secure, suffix: ""},
          ]
    name: Trivy
    runs-on: "ubuntu-22.04"
    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Configure AWS credentials for vault access
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ secrets.LIQUIBASE_VAULT_OIDC_ROLE_ARN }}
          aws-region: us-east-1

      - name: Get secrets from vault
        id: vault-secrets
        uses: aws-actions/aws-secretsmanager-get-secrets@v2
        with:
          secret-ids: |
            ,/vault/liquibase
          parse-json-secrets: true

      - name: Build ${{ matrix.image.name }}${{ matrix.image.suffix }} from Dockerfile
        run: |
          docker build -f ${{ matrix.image.dockerfile }} -t ${{ matrix.image.name }}${{ matrix.image.suffix }}:${{ github.sha }} .

      - name: Extract nested JARs and Python packages for deep scanning
        run: |
          set -e

          # Create extraction directory
          mkdir -p /tmp/extracted-deps

          # Create container from image to extract files
          container_id=$(docker create ${{ matrix.image.name }}${{ matrix.image.suffix }}:${{ github.sha }})

          echo "üì¶ Extracting all Liquibase JARs for deep scanning..."

          # Extract all JAR files from /liquibase/internal directory
          echo "üîç Extracting all JAR files from container..."

          # First, check for distribution archives in /liquibase/dist
          echo "üîç Checking /liquibase/dist for tar.gz archives..."
          if docker cp $container_id:/liquibase/dist /tmp/liquibase-dist 2>/dev/null; then
            echo "‚úì Found /liquibase/dist directory"

            # Extract all tar.gz archives
            find /tmp/liquibase-dist -name "*.tar.gz" -type f | while read archive; do
              archive_name=$(basename "$archive" .tar.gz)
              echo "  üì¶ Extracting $archive_name..."
              extract_dir="/tmp/liquibase-dist/${archive_name}-extracted"
              mkdir -p "$extract_dir"
              tar -xzf "$archive" -C "$extract_dir" 2>/dev/null || true

              # Find JARs in extracted archive
              jar_count=$(find "$extract_dir" -name "*.jar" -type f | wc -l)
              if [ $jar_count -gt 0 ]; then
                echo "  ‚úì Found $jar_count JAR(s) in $archive_name"

                # Extract each JAR from the archive
                find "$extract_dir" -name "*.jar" -type f | while read jar_file; do
                  jar_name=$(basename "$jar_file" .jar)
                  jar_extract="/tmp/extracted-deps/dist/${archive_name}/${jar_name}"
                  mkdir -p "$jar_extract"
                  unzip -q "$jar_file" -d "$jar_extract" 2>/dev/null || true

                  # Check for Spring Boot nested JARs and copy them as-is (don't extract)
                  if [ -d "$jar_extract/BOOT-INF/lib" ]; then
                    echo "    ‚úì Spring Boot JAR: $jar_name - preserving nested JAR files"
                    nested_count=0
                    nested_jar_dir="/tmp/extracted-deps/dist/${archive_name}/${jar_name}-nested-jars"
                    mkdir -p "$nested_jar_dir"

                    # Create a mapping file to track parent JAR relationships
                    mapping_file="/tmp/extracted-deps/jar-mapping.txt"

                    for nested_jar in "$jar_extract/BOOT-INF/lib"/*.jar; do
                      if [ -f "$nested_jar" ]; then
                        nested_count=$((nested_count + 1))
                        nested_jar_name=$(basename "$nested_jar")

                        # Copy the JAR file as-is, don't extract it
                        cp "$nested_jar" "$nested_jar_dir/" 2>/dev/null || true

                        # Record the parent ‚Üí nested relationship
                        echo "${jar_name}.jar|$nested_jar_name" >> "$mapping_file"
                      fi
                    done
                    echo "      ‚Üí Preserved $nested_count nested JAR file(s)"
                  fi
                done
              fi
            done
          else
            echo "‚ö† No /liquibase/dist directory found"
          fi

          # Copy entire internal directory for comprehensive scanning
          if docker cp $container_id:/liquibase/internal /tmp/liquibase-internal 2>/dev/null; then
            echo "‚úì Copied /liquibase/internal directory"

            # Count total JARs
            jar_count=$(find /tmp/liquibase-internal -name "*.jar" -type f | wc -l)
            echo "üìä Found $jar_count JAR files to scan"

            # Copy all JAR files preserving them for Trivy to scan
            mkdir -p /tmp/extracted-deps/internal-jars/lib
            mkdir -p /tmp/extracted-deps/internal-jars/extensions
            jar_num=0

            # Copy lib JARs as-is
            if [ -d /tmp/liquibase-internal/lib ]; then
              cp /tmp/liquibase-internal/lib/*.jar /tmp/extracted-deps/internal-jars/lib/ 2>/dev/null || true
              lib_jar_count=$(ls -1 /tmp/extracted-deps/internal-jars/lib/*.jar 2>/dev/null | wc -l)
              echo "  ‚úì Preserved $lib_jar_count lib JAR(s)"
            fi

            # Copy extension JARs as-is
            if [ -d /tmp/liquibase-internal/extensions ]; then
              cp /tmp/liquibase-internal/extensions/*.jar /tmp/extracted-deps/internal-jars/extensions/ 2>/dev/null || true
              ext_jar_count=$(ls -1 /tmp/extracted-deps/internal-jars/extensions/*.jar 2>/dev/null | wc -l)
              echo "  ‚úì Preserved $ext_jar_count extension JAR(s)"
            fi

            echo "‚úì Preserved $jar_count JAR files for scanning"
          else
            echo "‚ö† Could not copy /liquibase/internal directory"
          fi

          # Extract liquibase-checks.jar (contains GraalVM Python embedded dependencies)
          if docker cp $container_id:/liquibase/internal/extensions/liquibase-checks.jar /tmp/liquibase-checks.jar 2>/dev/null; then
            echo "‚úì Found liquibase-checks.jar"
            mkdir -p /tmp/extracted-deps/checks
            unzip -q /tmp/liquibase-checks.jar -d /tmp/extracted-deps/checks || true

            # Extract GraalVM Python packages to standard Python structure
            if [ -d /tmp/extracted-deps/checks/org.graalvm.python.vfs ]; then
              echo "‚úì Extracting GraalVM Python packages..."
              mkdir -p /tmp/extracted-deps/python-packages

              # Copy from both possible locations
              if [ -d /tmp/extracted-deps/checks/org.graalvm.python.vfs/venv/lib/python3.11/site-packages ]; then
                cp -r /tmp/extracted-deps/checks/org.graalvm.python.vfs/venv/lib/python3.11/site-packages/* /tmp/extracted-deps/python-packages/ 2>/dev/null || true
              fi
              if [ -d /tmp/extracted-deps/checks/org.graalvm.python.vfs/venv/Lib/site-packages ]; then
                cp -r /tmp/extracted-deps/checks/org.graalvm.python.vfs/venv/Lib/site-packages/* /tmp/extracted-deps/python-packages/ 2>/dev/null || true
              fi

              # Also extract bundled wheels
              if [ -d /tmp/extracted-deps/checks/META-INF/resources/libpython/ensurepip/_bundled ]; then
                mkdir -p /tmp/extracted-deps/python-bundled
                cp /tmp/extracted-deps/checks/META-INF/resources/libpython/ensurepip/_bundled/*.whl /tmp/extracted-deps/python-bundled/ 2>/dev/null || true
              fi
            fi
          else
            echo "‚ö† liquibase-checks.jar not found"
          fi

          # Cleanup container
          docker rm $container_id

          # Show what was extracted
          echo ""
          echo "üìä Extraction Summary:"
          total_files=$(find /tmp/extracted-deps -type f 2>/dev/null | wc -l)
          echo "Total files extracted: $total_files"

          if [ -d /tmp/extracted-deps/dist ]; then
            dist_archives=$(find /tmp/liquibase-dist -name "*.tar.gz" -type f 2>/dev/null | wc -l)
            dist_jars=$(find /tmp/liquibase-dist -name "*.jar" -type f 2>/dev/null | wc -l)
            nested_jars=$(find /tmp/extracted-deps/dist -type d -name "*-nested-jars" -exec sh -c 'ls -1 "{}"/*.jar 2>/dev/null | wc -l' \; 2>/dev/null | awk '{s+=$1} END {print s}')
            echo "Distribution archives: $dist_archives"
            echo "  - JARs in archives: $dist_jars"
            if [ "$nested_jars" -gt 0 ]; then
              echo "  - Spring Boot nested JARs: $nested_jars"
            fi
          fi

          if [ -d /tmp/extracted-deps/internal-jars ]; then
            lib_jars=$(ls -1 /tmp/extracted-deps/internal-jars/lib/*.jar 2>/dev/null | wc -l)
            ext_jars=$(ls -1 /tmp/extracted-deps/internal-jars/extensions/*.jar 2>/dev/null | wc -l)
            total_internal=$((lib_jars + ext_jars))
            echo "Internal JARs preserved: $total_internal"
            echo "  - Lib JARs: $lib_jars"
            echo "  - Extension JARs: $ext_jars"
          fi

          if [ -d /tmp/extracted-deps/python-packages ]; then
            python_pkgs=$(ls -1 /tmp/extracted-deps/python-packages 2>/dev/null | grep -E '\.(dist-info|egg-info)$' | wc -l)
            echo "Python packages found: $python_pkgs"
          fi

      - name: Generate SBOM with Syft
        uses: anchore/sbom-action@v0
        with:
          image: '${{ matrix.image.name }}${{ matrix.image.suffix }}:${{ github.sha }}'
          format: 'spdx-json'
          output-file: 'sbom.spdx.json'

      - name: Upload SBOM as artifact
        if: always()
        uses: actions/upload-artifact@v5
        with:
          name: sbom-${{ matrix.image.dockerfile == 'DockerfileSecure' && 'secure' || matrix.image.suffix != '' && matrix.image.suffix || 'community' }}
          path: sbom.spdx.json
          retention-days: 30

      - name: Run Trivy vulnerability scanner (Surface Scan - SARIF)
        uses: aquasecurity/trivy-action@0.33.1
        with:
          image-ref: '${{ matrix.image.name }}${{ matrix.image.suffix }}:${{ github.sha }}'
          vuln-type: 'os,library'
          format: 'sarif'
          output: 'trivy-surface.sarif'
          severity: 'HIGH,CRITICAL'
          exit-code: '0'
          limit-severities-for-sarif: true

      - name: Run Trivy vulnerability scanner (Surface Scan - JSON)
        uses: aquasecurity/trivy-action@0.33.1
        with:
          image-ref: '${{ matrix.image.name }}${{ matrix.image.suffix }}:${{ github.sha }}'
          vuln-type: 'os,library'
          format: 'json'
          output: 'trivy-surface.json'
          severity: 'HIGH,CRITICAL'
          exit-code: '0'

      - name: Run Trivy scanner on extracted nested JARs (Deep Scan - SARIF)
        if: always()
        uses: aquasecurity/trivy-action@0.33.1
        with:
          scan-type: 'rootfs'
          scan-ref: '/tmp/extracted-deps'
          vuln-type: 'library'
          format: 'sarif'
          output: 'trivy-deep.sarif'
          severity: 'HIGH,CRITICAL'
          exit-code: '0'
          limit-severities-for-sarif: true

      - name: Run Trivy scanner on extracted nested JARs (Deep Scan - JSON)
        if: always()
        uses: aquasecurity/trivy-action@0.33.1
        with:
          scan-type: 'rootfs'
          scan-ref: '/tmp/extracted-deps'
          vuln-type: 'library'
          format: 'json'
          output: 'trivy-deep.json'
          severity: 'HIGH,CRITICAL'
          exit-code: '0'

      - name: Run Grype scanner on SBOM
        if: always()
        id: grype_scan
        uses: anchore/scan-action@v5
        with:
          sbom: 'sbom.spdx.json'
          fail-build: false
          severity-cutoff: high
          output-format: sarif
        continue-on-error: true

      - name: Save Grype results to file
        if: always()
        run: |
          # The anchore/scan-action outputs to stdout, capture it
          # If the scan step succeeded, the SARIF should be in the default location
          if [ -f "results.sarif" ]; then
            mv results.sarif grype-results.sarif
            echo "‚úì Grype SARIF results saved to grype-results.sarif"
          elif [ -f "anchore-scan-results.sarif" ]; then
            mv anchore-scan-results.sarif grype-results.sarif
            echo "‚úì Grype SARIF results saved to grype-results.sarif"
          else
            echo "‚ö† Grype SARIF output file not found in expected locations"
            echo "Checking for any SARIF files created by Grype:"
            find . -name "*.sarif" -type f -mmin -5
          fi

      - name: Combine scan results and check for failures
        if: always()
        run: |
          set +e  # Don't fail immediately

          echo "üîç Analyzing scan results..."
          echo ""
          echo "Available scan result files:"
          ls -lh *.sarif *.json 2>/dev/null || echo "No scan result files found"
          echo ""

          # Count vulnerabilities from each scanner (using JSON for accuracy)
          surface_vulns=0
          deep_vulns=0
          grype_vulns=0

          if [ -f trivy-surface.json ]; then
            surface_vulns=$(jq '[.Results[]?.Vulnerabilities[]? | select(.Severity == "HIGH" or .Severity == "CRITICAL")] | length' trivy-surface.json 2>/dev/null || echo 0)
            echo "‚úì Trivy Surface Scan: $surface_vulns HIGH/CRITICAL vulnerabilities"
          else
            echo "‚ö† Trivy Surface Scan: JSON file not found"
          fi

          if [ -f trivy-deep.json ]; then
            deep_vulns=$(jq '[.Results[]?.Vulnerabilities[]? | select(.Severity == "HIGH" or .Severity == "CRITICAL")] | length' trivy-deep.json 2>/dev/null || echo 0)
            echo "‚úì Trivy Deep Scan: $deep_vulns HIGH/CRITICAL vulnerabilities"
          else
            echo "‚ö† Trivy Deep Scan: JSON file not found"
          fi

          if [ -f grype-results.sarif ]; then
            grype_vulns=$(jq '[.runs[].results[]? | select(.level == "error" or .level == "warning")] | length' grype-results.sarif 2>/dev/null || echo 0)
            echo "‚úì Grype SBOM Scan: $grype_vulns HIGH/CRITICAL vulnerabilities"
          else
            echo "‚ö† Grype SBOM Scan: SARIF file not found (scan may have failed or SBOM was empty)"
          fi

          total_vulns=$((surface_vulns + deep_vulns + grype_vulns))
          echo ""
          echo "üìä Total HIGH/CRITICAL vulnerabilities found: $total_vulns"

          # Create GitHub Actions Summary
          {
            echo "## üõ°Ô∏è Vulnerability Scan Results for \`${{ matrix.image.name }}${{ matrix.image.suffix }}\`"
            echo ""
            echo "**Total HIGH/CRITICAL Vulnerabilities: $total_vulns**"
            echo ""
            echo "| Scanner | Vulnerabilities | Status |"
            echo "|---------|-----------------|--------|"
            echo "| üîç Trivy Surface (OS + Top-level) | $surface_vulns | $([ $surface_vulns -eq 0 ] && echo '‚úÖ' || echo '‚ö†Ô∏è') |"
            echo "| üîé Trivy Deep (Nested JARs + Python) | $deep_vulns | $([ $deep_vulns -eq 0 ] && echo '‚úÖ' || echo '‚ö†Ô∏è') |"
            echo "| üìã Grype (SBOM-based) | $grype_vulns | $([ $grype_vulns -eq 0 ] && echo '‚úÖ' || echo '‚ö†Ô∏è') |"
            echo ""
          } >> $GITHUB_STEP_SUMMARY

          # Add detailed vulnerability tables using JSON format (more reliable than SARIF)
          if [ $surface_vulns -gt 0 ] && [ -f trivy-surface.json ]; then
            {
              echo "### üîç Trivy Surface Scan Details"
              echo ""
              echo "| Package | Vulnerability | Severity | Installed | Fixed |"
              echo "|---------|---------------|----------|-----------|-------|"
            } >> $GITHUB_STEP_SUMMARY

            jq -r '.Results[]?.Vulnerabilities[]? | select(.Severity == "HIGH" or .Severity == "CRITICAL") |
              "| \(.PkgName) | \(.VulnerabilityID) | \(.Severity) | \(.InstalledVersion) | \(.FixedVersion // "N/A") |"' \
              trivy-surface.json 2>/dev/null | head -20 >> $GITHUB_STEP_SUMMARY || echo "| Error parsing results | - | - | - | - |" >> $GITHUB_STEP_SUMMARY

            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          if [ $deep_vulns -gt 0 ] && [ -f trivy-deep.json ]; then
            {
              echo "### üîé Trivy Deep Scan Details (Nested JARs & Python)"
              echo ""
              echo "| Parent JAR | Package | Vulnerability | Severity | Installed | Fixed |"
              echo "|------------|---------|---------------|----------|-----------|-------|"
            } >> $GITHUB_STEP_SUMMARY

            # Process each vulnerability and look up parent JAR from mapping file
            jq -r '.Results[]? | .Target as $target | .Vulnerabilities[]? |
              select(.Severity == "HIGH" or .Severity == "CRITICAL") |
              "\($target)|\(.PkgPath // "")|\(.PkgName)|\(.VulnerabilityID)|\(.Severity)|\(.InstalledVersion)|\(.FixedVersion // "N/A")"' \
              trivy-deep.json 2>/dev/null | head -30 | while IFS='|' read -r target pkgpath pkg vuln severity installed fixed; do

              # Use PkgPath if available (contains JAR file path), otherwise use Target
              jar_path="${pkgpath:-$target}"

              # Extract JAR filename from path (handle both file paths and directory paths)
              if [[ "$jar_path" == *.jar ]]; then
                jar_file=$(basename "$jar_path" 2>/dev/null || echo "$jar_path")
              else
                # Path might be a directory containing a JAR, extract JAR name from path
                jar_file=$(echo "$jar_path" | grep -oE '[^/]+\.jar' | tail -1)
                if [ -z "$jar_file" ]; then
                  jar_file=$(basename "$jar_path" 2>/dev/null || echo "$jar_path")
                fi
              fi

              # Look up parent JAR from mapping file
              parent_jar="(internal)"
              if [ -f /tmp/extracted-deps/jar-mapping.txt ] && [ -n "$jar_file" ]; then
                # Try exact match first
                parent_match=$(grep -F "$jar_file" /tmp/extracted-deps/jar-mapping.txt 2>/dev/null | cut -d'|' -f1 | tr -d ' ' | head -1)
                if [ -n "$parent_match" ]; then
                  parent_jar="$parent_match"
                fi
              fi

              # Debug: Print first few lookups to help troubleshoot
              if [ -z "$debug_count" ]; then
                debug_count=0
              fi
              if [ $debug_count -lt 3 ]; then
                echo "DEBUG: target=$target, pkgpath=$pkgpath, jar_path=$jar_path, jar_file=$jar_file, parent_jar=$parent_jar"
                debug_count=$((debug_count + 1))
              fi

              echo "| $parent_jar | $pkg | $vuln | $severity | $installed | $fixed |" >> $GITHUB_STEP_SUMMARY
            done

            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          if [ $grype_vulns -gt 0 ] && [ -f grype-results.sarif ]; then
            {
              echo "### üìã Grype SBOM Scan Details"
              echo ""
              echo "| Package | Vulnerability | Severity | Installed | Fixed |"
              echo "|---------|---------------|----------|-----------|-------|"
            } >> $GITHUB_STEP_SUMMARY

            # Grype SARIF has different structure
            jq -r '.runs[].results[] |
              (.ruleId // "N/A") as $cve |
              (try (.properties.packageName // .locations[0].logicalLocations[0].name) // "N/A") as $pkg |
              (.level // "unknown") as $severity |
              (try (.properties.installedVersion // "N/A") catch "N/A") as $installed |
              (try (.properties.fixedVersion // "N/A") catch "N/A") as $fixed |
              "| \($pkg) | \($cve) | \($severity | ascii_upcase) | \($installed) | \($fixed) |"' \
              grype-results.sarif 2>/dev/null | head -20 >> $GITHUB_STEP_SUMMARY || echo "| Error parsing results | - | - | - | - |" >> $GITHUB_STEP_SUMMARY

            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          # Add scanner information
          {
            echo "---"
            echo ""
            echo "### üìñ Scanner Information"
            echo ""
            echo "- **Trivy Surface**: Scans OS packages and top-level libraries"
            echo "- **Trivy Deep**: Extracts and scans nested Spring Boot JARs (BOOT-INF/lib) and GraalVM Python packages"
            echo "- **Grype**: SBOM-based validation for comprehensive dependency analysis"
            echo ""
            echo "üí° **Note**: Deep scan detects vulnerabilities in nested dependencies that standard scans miss."
          } >> $GITHUB_STEP_SUMMARY

          # Create combined summary file
          cat > scan-summary.txt <<EOF
          # Vulnerability Scan Summary - ${{ matrix.image.name }}${{ matrix.image.suffix }}

          ## Scan Results
          - **Trivy Surface Scan**: $surface_vulns vulnerabilities
          - **Trivy Deep Scan (Nested JARs)**: $deep_vulns vulnerabilities
          - **Grype SBOM Scan**: $grype_vulns vulnerabilities
          - **Total**: $total_vulns HIGH/CRITICAL vulnerabilities

          ## Scanner Details
          - Trivy Surface: OS packages and top-level libraries
          - Trivy Deep: Extracted Spring Boot nested JARs and GraalVM Python packages
          - Grype: SBOM-based comprehensive dependency analysis
          EOF

          echo "Scan summary created"

          # Create enhanced vulnerability report with parent JAR mapping
          report_file="vulnerability-report-enhanced.md"

          {
            echo "# Enhanced Vulnerability Report"
            echo ""
            echo "**Image**: \`${{ matrix.image.name }}${{ matrix.image.suffix }}\`"
            echo "**Build SHA**: \`${{ github.sha }}\`"
            echo "**Scan Date**: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
            echo ""
            echo "## Summary"
            echo ""
            echo "| Scanner | HIGH/CRITICAL Vulnerabilities |"
            echo "|---------|-------------------------------|"
            echo "| Trivy Surface (OS + Top-level) | $surface_vulns |"
            echo "| Trivy Deep (Nested JARs + Python) | $deep_vulns |"
            echo "| Grype (SBOM-based) | $grype_vulns |"
            echo "| **Total** | **$total_vulns** |"
            echo ""
          } > "$report_file"

          # Add parent JAR mapping section
          if [ -f /tmp/extracted-deps/jar-mapping.txt ]; then
            {
              echo "## Parent JAR Relationships"
              echo ""
              echo "The following shows which Liquibase JARs contain vulnerable nested dependencies:"
              echo ""
              echo "\`\`\`"
              cat /tmp/extracted-deps/jar-mapping.txt | sort | uniq
              echo "\`\`\`"
              echo ""
            } >> "$report_file"
          fi

          # Add detailed vulnerability table with parent JAR context
          if [ -f trivy-deep.json ]; then
            {
              echo "## Detailed Vulnerability Analysis"
              echo ""
              echo "### Nested JAR Vulnerabilities"
              echo ""
              echo "| Parent JAR | Nested JAR | Vulnerability | Severity | Installed | Fixed |"
              echo "|------------|------------|---------------|----------|-----------|-------|"
            } >> "$report_file"

            # Process each vulnerability and match with parent JAR
            jq -r '.Results[]? | .Target as $target | .Vulnerabilities[]? |
              select(.Severity == "HIGH" or .Severity == "CRITICAL") |
              "\($target)|\(.PkgName)|\(.VulnerabilityID)|\(.Severity)|\(.InstalledVersion)|\(.FixedVersion // "-")"' \
              trivy-deep.json 2>/dev/null | while IFS='|' read -r target pkg vuln severity installed fixed; do

              # Extract JAR name from target path
              jar_file=$(basename "$target" 2>/dev/null || echo "$target")

              # Find parent JAR from mapping file
              if [ -f /tmp/extracted-deps/jar-mapping.txt ]; then
                parent_jar=$(grep "$jar_file" /tmp/extracted-deps/jar-mapping.txt | cut -d'|' -f1 | tr -d ' ' | head -1)
                if [ -z "$parent_jar" ]; then
                  parent_jar="(internal)"
                fi
              else
                parent_jar="(unknown)"
              fi

              echo "| $parent_jar | $jar_file | $vuln | $severity | $installed | $fixed |" >> "$report_file"
            done

            echo "" >> "$report_file"
          fi

          # Add Python vulnerabilities
          if [ -f trivy-deep.json ]; then
            python_vulns=$(jq '[.Results[]? | select(.Type == "python-pkg") | .Vulnerabilities[]? | select(.Severity == "HIGH" or .Severity == "CRITICAL")] | length' trivy-deep.json 2>/dev/null || echo 0)

            if [ "$python_vulns" -gt 0 ]; then
              {
                echo "### Python Package Vulnerabilities"
                echo ""
                echo "These are found in \`liquibase-checks.jar\` (GraalVM Python VFS)"
                echo ""
                echo "| Package | Vulnerability | Severity | Installed | Fixed |"
                echo "|---------|---------------|----------|-----------|-------|"
              } >> "$report_file"

              jq -r '.Results[]? | select(.Type == "python-pkg") | .Vulnerabilities[]? |
                select(.Severity == "HIGH" or .Severity == "CRITICAL") |
                "\(.PkgName)|\(.VulnerabilityID)|\(.Severity)|\(.InstalledVersion)|\(.FixedVersion // "-")"' \
                trivy-deep.json 2>/dev/null | while IFS='|' read -r pkg vuln severity installed fixed; do
                echo "| $pkg | $vuln | $severity | $installed | $fixed |" >> "$report_file"
              done

              echo "" >> "$report_file"
            fi
          fi

          echo "‚úì Enhanced vulnerability report created: $report_file"

          # Exit with error if vulnerabilities found
          if [ $total_vulns -gt 0 ]; then
            echo "‚ùå Vulnerabilities detected - failing build"
            exit 1
          else
            echo "‚úÖ No HIGH/CRITICAL vulnerabilities found"
            exit 0
          fi

      - name: Upload enhanced vulnerability report
        if: always()
        uses: actions/upload-artifact@v5
        with:
          name: vulnerability-report-${{ matrix.image.dockerfile == 'DockerfileSecure' && 'secure' || matrix.image.suffix != '' && matrix.image.suffix || 'community' }}
          path: vulnerability-report-enhanced.md
          retention-days: 90

      # - name: Notify Slack on Build Failure
      #   if: failure()
      #   uses: rtCamp/action-slack-notify@v2
      #   env:
      #     SLACK_COLOR: 'failure'
      #     SLACK_MESSAGE: "View details on GitHub Actions: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}. Triggered by repository: ${{ github.repository }} and job: ${{ github.job }}"
      #     SLACK_TITLE: "‚ùå ${{ github.repository }} ‚ùå Trivy failed on branch ${{ github.ref_name }} for commit ${{ github.sha }} in repository ${{ github.repository }}"
      #     SLACK_USERNAME: liquibot
      #     SLACK_WEBHOOK: ${{ env.DOCKER_SLACK_WEBHOOK_URL }}
      #     SLACK_ICON_EMOJI: ":whale:"
      #     SLACK_FOOTER: "${{ github.repository }} - ${{ matrix.image.name }}${{ matrix.image.suffix }}:${{ github.sha }}"
      #     SLACK_LINK_NAMES: true

      - name: Upload Trivy Surface scan results to GitHub Security tab
        if: always()
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: 'trivy-surface.sarif'
          category: '${{ matrix.image.name }}${{ matrix.image.suffix }}-surface'

      - name: Upload Trivy Deep scan results to GitHub Security tab
        if: always()
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: 'trivy-deep.sarif'
          category: '${{ matrix.image.name }}${{ matrix.image.suffix }}-deep'

      - name: Check if Grype SARIF exists
        if: always()
        id: check_grype
        run: |
          if [ -f "grype-results.sarif" ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Upload Grype scan results to GitHub Security tab
        if: always() && steps.check_grype.outputs.exists == 'true'
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: 'grype-results.sarif'
          category: '${{ matrix.image.name }}${{ matrix.image.suffix }}-grype'

      - name: Generate Security Report
        if: always()
        uses: rsdmike/github-security-report-action@v3.0.4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          outputDir: ./reports/trivy${{ matrix.image.dockerfile == 'DockerfileSecure' && '-secure' || matrix.image.suffix }}/
          sarifReportDir: .

      - name: Upload Security Report
        if: always()
        uses: actions/upload-artifact@v5
        with:
          name: security-report-trivy${{ matrix.image.dockerfile == 'DockerfileSecure' && '-secure' || matrix.image.suffix }}
          path: ./reports/trivy${{ matrix.image.dockerfile == 'DockerfileSecure' && '-secure' || matrix.image.suffix }}/summary.pdf

      - name: Upload Scan Summary
        if: always()
        uses: actions/upload-artifact@v5
        with:
          name: scan-summary-${{ matrix.image.dockerfile == 'DockerfileSecure' && 'secure' || matrix.image.suffix != '' && matrix.image.suffix || 'community' }}
          path: scan-summary.txt
          retention-days: 30


  scout:
    strategy:
      fail-fast: false
      matrix:
        image: [
          {dockerfile: Dockerfile, name: liquibase/liquibase, suffix: ""},
          {dockerfile: Dockerfile.alpine, name: liquibase/liquibase, suffix: "-alpine"},
          {dockerfile: DockerfileSecure, name: liquibase/liquibase-secure, suffix: ""},
          ]
    name: Scout
    runs-on: "ubuntu-22.04"
    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Build ${{ matrix.image.name }}${{ matrix.image.suffix }} from Dockerfile
        run: |
          docker build -f ${{ matrix.image.dockerfile }} -t ${{ matrix.image.name }}${{ matrix.image.suffix }}:${{ github.sha }} .

      - name: Configure AWS credentials for vault access
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ secrets.LIQUIBASE_VAULT_OIDC_ROLE_ARN }}
          aws-region: us-east-1

      - name: Get secrets from vault
        id: vault-secrets
        uses: aws-actions/aws-secretsmanager-get-secrets@v2
        with:
          secret-ids: |
            ,/vault/liquibase
          parse-json-secrets: true

      - name: Decode DOCKERHUB_USERNAME
        run: |
          decoded_username=$(echo "${{ env.DOCKERHUB_USERNAME }}" | base64 -d)
          echo "DOCKERHUB_USERNAME_DECODED=$decoded_username" >> $GITHUB_ENV

      - uses: docker/login-action@v3
        with:
          username: ${{ env.DOCKERHUB_USERNAME_DECODED }}
          password: ${{ env.DOCKERHUB_TOKEN }}

      - name: Docker Scout
        uses: docker/scout-action@v1.18.2
        with:
          command: cves
          image: '${{ matrix.image.name }}${{ matrix.image.suffix }}:${{ github.sha }}'
          github-token: ${{ secrets.GITHUB_TOKEN }}
          write-comment: true
          sarif-file: 'scout-results.sarif'
          summary: true
          exit-code: true
          only-severities: "critical,high"

      # - name: Notify Slack on Build Failure
      #   if: failure()
      #   uses: rtCamp/action-slack-notify@v2
      #   env:
      #     SLACK_COLOR: 'failure'
      #     SLACK_MESSAGE: "View details on GitHub Actions: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}. Triggered by repository: ${{ github.repository }} and job: ${{ github.job }}"
      #     SLACK_TITLE: "‚ùå ${{ github.repository }} ‚ùå Docker Scout failed on branch ${{ github.ref_name }} for commit ${{ github.sha }} in repository ${{ github.repository }}"
      #     SLACK_USERNAME: liquibot
      #     SLACK_WEBHOOK: ${{ env.DOCKER_SLACK_WEBHOOK_URL }}
      #     SLACK_ICON_EMOJI: ":whale:"
      #     SLACK_FOOTER: "${{ github.repository }} - ${{ matrix.image.name }}${{ matrix.image.suffix }}:${{ github.sha }}"
      #     SLACK_LINK_NAMES: true

      - name: Upload Scout scan results to GitHub Security tab
        if: always()
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: 'scout-results.sarif'
          category: '${{ matrix.image.name }}${{ matrix.image.suffix }}'

      - name: Generate Security Report
        if: always()
        uses: rsdmike/github-security-report-action@v3.0.4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          outputDir: ./reports/scout${{ matrix.image.dockerfile == 'DockerfileSecure' && '-secure' || matrix.image.suffix }}/
          sarifReportDir: .

      - name: Upload Security Report
        if: always()
        uses: actions/upload-artifact@v5
        with:
          name: security-report-scout${{ matrix.image.dockerfile == 'DockerfileSecure' && '-secure' || matrix.image.suffix }}
          path: ./reports/scout${{ matrix.image.dockerfile == 'DockerfileSecure' && '-secure' || matrix.image.suffix }}/summary.pdf