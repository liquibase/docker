# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

name: Vulnerability Scanning

on:
  workflow_dispatch:
  push:
    branches: [ "main" ]
  pull_request:
    # The branches below must be a subset of the branches above
    branches: [ "main" ]
  schedule:
    - cron: '0 7 * * 1-5' # Run every weekday at 7am UTC

permissions:
  contents: read
  id-token: write # Required for AWS OIDC authentication
  security-events: write # Required for uploading SARIF results to GitHub Security tab
  actions: read # Required for private repositories to get Action run status
  pull-requests: write # Required for writing comments on pull requests

jobs:
  trivy:
    strategy:
      fail-fast: false
      matrix:
        image: [
          {dockerfile: Dockerfile, name: liquibase/liquibase, suffix: ""},
          {dockerfile: Dockerfile.alpine, name: liquibase/liquibase, suffix: "-alpine"},
          {dockerfile: DockerfileSecure, name: liquibase/liquibase-secure, suffix: ""},
          ]
    name: Trivy
    runs-on: "ubuntu-22.04"
    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Configure AWS credentials for vault access
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ secrets.LIQUIBASE_VAULT_OIDC_ROLE_ARN }}
          aws-region: us-east-1

      - name: Get secrets from vault
        id: vault-secrets
        uses: aws-actions/aws-secretsmanager-get-secrets@v2
        with:
          secret-ids: |
            ,/vault/liquibase
          parse-json-secrets: true

      - name: Build ${{ matrix.image.name }}${{ matrix.image.suffix }} from Dockerfile
        run: |
          docker build -f ${{ matrix.image.dockerfile }} -t ${{ matrix.image.name }}${{ matrix.image.suffix }}:${{ github.sha }} .

      - name: Extract nested JARs and Python packages for deep scanning
        run: |
          set -e

          # Create extraction directory
          mkdir -p /tmp/extracted-deps

          # Create container from image to extract files
          container_id=$(docker create ${{ matrix.image.name }}${{ matrix.image.suffix }}:${{ github.sha }})

          echo "üì¶ Extracting Liquibase JARs for deep scanning..."

          # Extract liquibase-license-tracking.jar (contains Spring Boot fat JAR with nested dependencies)
          if docker cp $container_id:/liquibase/internal/lib/liquibase-license-tracking.jar /tmp/liquibase-license-tracking.jar 2>/dev/null; then
            echo "‚úì Found liquibase-license-tracking.jar"
            mkdir -p /tmp/extracted-deps/license-tracking
            unzip -q /tmp/liquibase-license-tracking.jar -d /tmp/extracted-deps/license-tracking || true

            # Extract nested JARs from BOOT-INF/lib (Spring Boot structure)
            if [ -d /tmp/extracted-deps/license-tracking/BOOT-INF/lib ]; then
              echo "‚úì Extracting nested JARs from BOOT-INF/lib..."
              mkdir -p /tmp/extracted-deps/nested-jars
              for jar in /tmp/extracted-deps/license-tracking/BOOT-INF/lib/*.jar; do
                if [ -f "$jar" ]; then
                  jar_name=$(basename "$jar" .jar)
                  echo "  - Extracting $jar_name"
                  mkdir -p "/tmp/extracted-deps/nested-jars/$jar_name"
                  unzip -q "$jar" -d "/tmp/extracted-deps/nested-jars/$jar_name" || true
                fi
              done
            fi
          else
            echo "‚ö† liquibase-license-tracking.jar not found (expected for Community edition)"
          fi

          # Extract liquibase-checks.jar (contains GraalVM Python embedded dependencies)
          if docker cp $container_id:/liquibase/internal/extensions/liquibase-checks.jar /tmp/liquibase-checks.jar 2>/dev/null; then
            echo "‚úì Found liquibase-checks.jar"
            mkdir -p /tmp/extracted-deps/checks
            unzip -q /tmp/liquibase-checks.jar -d /tmp/extracted-deps/checks || true

            # Extract GraalVM Python packages to standard Python structure
            if [ -d /tmp/extracted-deps/checks/org.graalvm.python.vfs ]; then
              echo "‚úì Extracting GraalVM Python packages..."
              mkdir -p /tmp/extracted-deps/python-packages

              # Copy from both possible locations
              if [ -d /tmp/extracted-deps/checks/org.graalvm.python.vfs/venv/lib/python3.11/site-packages ]; then
                cp -r /tmp/extracted-deps/checks/org.graalvm.python.vfs/venv/lib/python3.11/site-packages/* /tmp/extracted-deps/python-packages/ 2>/dev/null || true
              fi
              if [ -d /tmp/extracted-deps/checks/org.graalvm.python.vfs/venv/Lib/site-packages ]; then
                cp -r /tmp/extracted-deps/checks/org.graalvm.python.vfs/venv/Lib/site-packages/* /tmp/extracted-deps/python-packages/ 2>/dev/null || true
              fi

              # Also extract bundled wheels
              if [ -d /tmp/extracted-deps/checks/META-INF/resources/libpython/ensurepip/_bundled ]; then
                mkdir -p /tmp/extracted-deps/python-bundled
                cp /tmp/extracted-deps/checks/META-INF/resources/libpython/ensurepip/_bundled/*.whl /tmp/extracted-deps/python-bundled/ 2>/dev/null || true
              fi
            fi
          else
            echo "‚ö† liquibase-checks.jar not found"
          fi

          # Cleanup container
          docker rm $container_id

          # Show what was extracted
          echo ""
          echo "üìä Extraction Summary:"
          find /tmp/extracted-deps -type f | wc -l | xargs echo "Total files extracted:"

          if [ -d /tmp/extracted-deps/nested-jars ]; then
            echo "Nested JARs extracted: $(ls -1 /tmp/extracted-deps/nested-jars | wc -l)"
          fi

          if [ -d /tmp/extracted-deps/python-packages ]; then
            echo "Python packages found: $(ls -1 /tmp/extracted-deps/python-packages 2>/dev/null | grep -E '\.(dist-info|egg-info)$' | wc -l)"
          fi

      - name: Generate SBOM with Syft
        uses: anchore/sbom-action@v0
        with:
          image: '${{ matrix.image.name }}${{ matrix.image.suffix }}:${{ github.sha }}'
          format: 'spdx-json'
          output-file: 'sbom.spdx.json'

      - name: Upload SBOM as artifact
        if: always()
        uses: actions/upload-artifact@v5
        with:
          name: sbom-${{ matrix.image.dockerfile == 'DockerfileSecure' && 'secure' || matrix.image.suffix != '' && matrix.image.suffix || 'community' }}
          path: sbom.spdx.json
          retention-days: 30

      - name: Run Trivy vulnerability scanner (Surface Scan)
        uses: aquasecurity/trivy-action@0.33.1
        with:
          image-ref: '${{ matrix.image.name }}${{ matrix.image.suffix }}:${{ github.sha }}'
          vuln-type: 'os,library'
          format: 'sarif'
          output: 'trivy-surface.sarif'
          severity: 'HIGH,CRITICAL'
          exit-code: '0'
          limit-severities-for-sarif: true

      - name: Run Trivy scanner on extracted nested JARs (Deep Scan)
        if: always()
        uses: aquasecurity/trivy-action@0.33.1
        with:
          scan-type: 'rootfs'
          scan-ref: '/tmp/extracted-deps'
          vuln-type: 'library'
          format: 'sarif'
          output: 'trivy-deep.sarif'
          severity: 'HIGH,CRITICAL'
          exit-code: '0'
          limit-severities-for-sarif: true

      - name: Run Grype scanner on SBOM
        if: always()
        id: grype_scan
        uses: anchore/scan-action@v5
        with:
          sbom: 'sbom.spdx.json'
          fail-build: false
          severity-cutoff: high
          output-format: sarif
        continue-on-error: true

      - name: Save Grype results to file
        if: always()
        run: |
          # The anchore/scan-action outputs to stdout, capture it
          # If the scan step succeeded, the SARIF should be in the default location
          if [ -f "results.sarif" ]; then
            mv results.sarif grype-results.sarif
            echo "‚úì Grype SARIF results saved to grype-results.sarif"
          elif [ -f "anchore-scan-results.sarif" ]; then
            mv anchore-scan-results.sarif grype-results.sarif
            echo "‚úì Grype SARIF results saved to grype-results.sarif"
          else
            echo "‚ö† Grype SARIF output file not found in expected locations"
            echo "Checking for any SARIF files created by Grype:"
            find . -name "*.sarif" -type f -mmin -5
          fi

      - name: Combine scan results and check for failures
        if: always()
        run: |
          set +e  # Don't fail immediately

          echo "üîç Analyzing scan results..."
          echo ""
          echo "Available scan result files:"
          ls -lh *.sarif *.json 2>/dev/null || echo "No scan result files found"
          echo ""

          # Count vulnerabilities from each scanner
          surface_vulns=0
          deep_vulns=0
          grype_vulns=0

          if [ -f trivy-surface.sarif ]; then
            surface_vulns=$(jq '[.runs[].results[]? | select(.level == "error" or .level == "warning")] | length' trivy-surface.sarif 2>/dev/null || echo 0)
            echo "‚úì Trivy Surface Scan: $surface_vulns HIGH/CRITICAL vulnerabilities"
          else
            echo "‚ö† Trivy Surface Scan: SARIF file not found"
          fi

          if [ -f trivy-deep.sarif ]; then
            deep_vulns=$(jq '[.runs[].results[]? | select(.level == "error" or .level == "warning")] | length' trivy-deep.sarif 2>/dev/null || echo 0)
            echo "‚úì Trivy Deep Scan: $deep_vulns HIGH/CRITICAL vulnerabilities"
          else
            echo "‚ö† Trivy Deep Scan: SARIF file not found"
          fi

          if [ -f grype-results.sarif ]; then
            grype_vulns=$(jq '[.runs[].results[]? | select(.level == "error" or .level == "warning")] | length' grype-results.sarif 2>/dev/null || echo 0)
            echo "‚úì Grype SBOM Scan: $grype_vulns HIGH/CRITICAL vulnerabilities"
          else
            echo "‚ö† Grype SBOM Scan: SARIF file not found (scan may have failed or SBOM was empty)"
          fi

          total_vulns=$((surface_vulns + deep_vulns + grype_vulns))
          echo ""
          echo "üìä Total HIGH/CRITICAL vulnerabilities found: $total_vulns"

          # Create combined summary
          cat > scan-summary.txt <<EOF
          # Vulnerability Scan Summary - ${{ matrix.image.name }}${{ matrix.image.suffix }}

          ## Scan Results
          - **Trivy Surface Scan**: $surface_vulns vulnerabilities
          - **Trivy Deep Scan (Nested JARs)**: $deep_vulns vulnerabilities
          - **Grype SBOM Scan**: $grype_vulns vulnerabilities
          - **Total**: $total_vulns HIGH/CRITICAL vulnerabilities

          ## Scanner Details
          - Trivy Surface: OS packages and top-level libraries
          - Trivy Deep: Extracted Spring Boot nested JARs and GraalVM Python packages
          - Grype: SBOM-based comprehensive dependency analysis
          EOF

          echo "Scan summary created"

          # Exit with error if vulnerabilities found
          if [ $total_vulns -gt 0 ]; then
            echo "‚ùå Vulnerabilities detected - failing build"
            exit 1
          else
            echo "‚úÖ No HIGH/CRITICAL vulnerabilities found"
            exit 0
          fi

      # - name: Notify Slack on Build Failure
      #   if: failure()
      #   uses: rtCamp/action-slack-notify@v2
      #   env:
      #     SLACK_COLOR: 'failure'
      #     SLACK_MESSAGE: "View details on GitHub Actions: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}. Triggered by repository: ${{ github.repository }} and job: ${{ github.job }}"
      #     SLACK_TITLE: "‚ùå ${{ github.repository }} ‚ùå Trivy failed on branch ${{ github.ref_name }} for commit ${{ github.sha }} in repository ${{ github.repository }}"
      #     SLACK_USERNAME: liquibot
      #     SLACK_WEBHOOK: ${{ env.DOCKER_SLACK_WEBHOOK_URL }}
      #     SLACK_ICON_EMOJI: ":whale:"
      #     SLACK_FOOTER: "${{ github.repository }} - ${{ matrix.image.name }}${{ matrix.image.suffix }}:${{ github.sha }}"
      #     SLACK_LINK_NAMES: true

      - name: Upload Trivy Surface scan results to GitHub Security tab
        if: always()
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: 'trivy-surface.sarif'
          category: '${{ matrix.image.name }}${{ matrix.image.suffix }}-surface'

      - name: Upload Trivy Deep scan results to GitHub Security tab
        if: always()
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: 'trivy-deep.sarif'
          category: '${{ matrix.image.name }}${{ matrix.image.suffix }}-deep'

      - name: Check if Grype SARIF exists
        if: always()
        id: check_grype
        run: |
          if [ -f "grype-results.sarif" ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Upload Grype scan results to GitHub Security tab
        if: always() && steps.check_grype.outputs.exists == 'true'
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: 'grype-results.sarif'
          category: '${{ matrix.image.name }}${{ matrix.image.suffix }}-grype'

      - name: Generate Security Report
        if: always()
        uses: rsdmike/github-security-report-action@v3.0.4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          outputDir: ./reports/trivy${{ matrix.image.dockerfile == 'DockerfileSecure' && '-secure' || matrix.image.suffix }}/
          sarifReportDir: .

      - name: Upload Security Report
        if: always()
        uses: actions/upload-artifact@v5
        with:
          name: security-report-trivy${{ matrix.image.dockerfile == 'DockerfileSecure' && '-secure' || matrix.image.suffix }}
          path: ./reports/trivy${{ matrix.image.dockerfile == 'DockerfileSecure' && '-secure' || matrix.image.suffix }}/summary.pdf

      - name: Upload Scan Summary
        if: always()
        uses: actions/upload-artifact@v5
        with:
          name: scan-summary-${{ matrix.image.dockerfile == 'DockerfileSecure' && 'secure' || matrix.image.suffix != '' && matrix.image.suffix || 'community' }}
          path: scan-summary.txt
          retention-days: 30


  scout:
    strategy:
      fail-fast: false
      matrix:
        image: [
          {dockerfile: Dockerfile, name: liquibase/liquibase, suffix: ""},
          {dockerfile: Dockerfile.alpine, name: liquibase/liquibase, suffix: "-alpine"},
          {dockerfile: DockerfileSecure, name: liquibase/liquibase-secure, suffix: ""},
          ]
    name: Scout
    runs-on: "ubuntu-22.04"
    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Build ${{ matrix.image.name }}${{ matrix.image.suffix }} from Dockerfile
        run: |
          docker build -f ${{ matrix.image.dockerfile }} -t ${{ matrix.image.name }}${{ matrix.image.suffix }}:${{ github.sha }} .

      - name: Configure AWS credentials for vault access
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ secrets.LIQUIBASE_VAULT_OIDC_ROLE_ARN }}
          aws-region: us-east-1

      - name: Get secrets from vault
        id: vault-secrets
        uses: aws-actions/aws-secretsmanager-get-secrets@v2
        with:
          secret-ids: |
            ,/vault/liquibase
          parse-json-secrets: true

      - name: Decode DOCKERHUB_USERNAME
        run: |
          decoded_username=$(echo "${{ env.DOCKERHUB_USERNAME }}" | base64 -d)
          echo "DOCKERHUB_USERNAME_DECODED=$decoded_username" >> $GITHUB_ENV

      - uses: docker/login-action@v3
        with:
          username: ${{ env.DOCKERHUB_USERNAME_DECODED }}
          password: ${{ env.DOCKERHUB_TOKEN }}

      - name: Docker Scout
        uses: docker/scout-action@v1.18.2
        with:
          command: cves
          image: '${{ matrix.image.name }}${{ matrix.image.suffix }}:${{ github.sha }}'
          github-token: ${{ secrets.GITHUB_TOKEN }}
          write-comment: true
          sarif-file: 'scout-results.sarif'
          summary: true
          exit-code: true
          only-severities: "critical,high"

      # - name: Notify Slack on Build Failure
      #   if: failure()
      #   uses: rtCamp/action-slack-notify@v2
      #   env:
      #     SLACK_COLOR: 'failure'
      #     SLACK_MESSAGE: "View details on GitHub Actions: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}. Triggered by repository: ${{ github.repository }} and job: ${{ github.job }}"
      #     SLACK_TITLE: "‚ùå ${{ github.repository }} ‚ùå Docker Scout failed on branch ${{ github.ref_name }} for commit ${{ github.sha }} in repository ${{ github.repository }}"
      #     SLACK_USERNAME: liquibot
      #     SLACK_WEBHOOK: ${{ env.DOCKER_SLACK_WEBHOOK_URL }}
      #     SLACK_ICON_EMOJI: ":whale:"
      #     SLACK_FOOTER: "${{ github.repository }} - ${{ matrix.image.name }}${{ matrix.image.suffix }}:${{ github.sha }}"
      #     SLACK_LINK_NAMES: true

      - name: Upload Scout scan results to GitHub Security tab
        if: always()
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: 'scout-results.sarif'
          category: '${{ matrix.image.name }}${{ matrix.image.suffix }}'

      - name: Generate Security Report
        if: always()
        uses: rsdmike/github-security-report-action@v3.0.4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          outputDir: ./reports/scout${{ matrix.image.dockerfile == 'DockerfileSecure' && '-secure' || matrix.image.suffix }}/
          sarifReportDir: .

      - name: Upload Security Report
        if: always()
        uses: actions/upload-artifact@v5
        with:
          name: security-report-scout${{ matrix.image.dockerfile == 'DockerfileSecure' && '-secure' || matrix.image.suffix }}
          path: ./reports/scout${{ matrix.image.dockerfile == 'DockerfileSecure' && '-secure' || matrix.image.suffix }}/summary.pdf