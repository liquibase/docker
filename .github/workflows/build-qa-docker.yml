name: Build QA Docker Images

permissions:
  contents: read
  id-token: write
  actions: read

on:
  workflow_dispatch:
    inputs:
      liquibaseBranch:
        description: "Liquibase branch to build from (e.g., main, feature-branch)"
        required: true
        type: string
        default: "main"
      buildTargets:
        description: "Select which Docker images to build"
        required: true
        type: choice
        options:
          - "All (OSS + Alpine + Pro)"
          - "OSS Only (Standard + Alpine)"
          - "Pro Only"
          - "Standard OSS Only"
          - "Alpine OSS Only"
        default: "All (OSS + Alpine + Pro)"

jobs:
  set-matrix:
    name: "Generate Build Matrix"
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - name: Set matrix dynamically
        id: set-matrix
        run: |
          matrix_items=()

          case "${{ inputs.buildTargets }}" in
            "All (OSS + Alpine + Pro)")
              matrix_items+=('{"dockerfile": "Dockerfile", "image_name": "liquibase-qa", "suffix": "", "build_type": "oss"}')
              matrix_items+=('{"dockerfile": "Dockerfile.alpine", "image_name": "liquibase-qa-alpine", "suffix": "-alpine", "build_type": "oss"}')
              matrix_items+=('{"dockerfile": "DockerfilePro", "image_name": "liquibase-pro-qa", "suffix": "-pro", "build_type": "pro"}')
              ;;
            "OSS Only (Standard + Alpine)")
              matrix_items+=('{"dockerfile": "Dockerfile", "image_name": "liquibase-qa", "suffix": "", "build_type": "oss"}')
              matrix_items+=('{"dockerfile": "Dockerfile.alpine", "image_name": "liquibase-qa-alpine", "suffix": "-alpine", "build_type": "oss"}')
              ;;
            "Pro Only")
              matrix_items+=('{"dockerfile": "DockerfilePro", "image_name": "liquibase-pro-qa", "suffix": "-pro", "build_type": "pro"}')
              ;;
            "Standard OSS Only")
              matrix_items+=('{"dockerfile": "Dockerfile", "image_name": "liquibase-qa", "suffix": "", "build_type": "oss"}')
              ;;
            "Alpine OSS Only")
              matrix_items+=('{"dockerfile": "Dockerfile.alpine", "image_name": "liquibase-qa-alpine", "suffix": "-alpine", "build_type": "oss"}')
              ;;
          esac

          # Join array elements with commas
          IFS=','
          matrix_json="{\"include\":[${matrix_items[*]}]}"

          echo "Selected build targets: ${{ inputs.buildTargets }}"
          echo "Generated matrix: $matrix_json"
          echo "matrix=$matrix_json" >> $GITHUB_OUTPUT

  build-qa-docker:
    name: "Build and Push QA Docker Images"
    runs-on: ubuntu-latest
    needs: set-matrix
    strategy:
      matrix: ${{ fromJSON(needs.set-matrix.outputs.matrix) }}
    steps:
      - name: Configure AWS credentials for vault access
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ secrets.LIQUIBASE_VAULT_OIDC_ROLE_ARN }}
          aws-region: us-east-1

      - name: Get secrets from vault
        id: vault-secrets-liquibase
        uses: aws-actions/aws-secretsmanager-get-secrets@v2
        with:
          secret-ids: |
            ,/vault/liquibase
          parse-json-secrets: true

      - name: Configure AWS credentials for Liquibase Pro builds
        if: ${{ matrix.build_type == 'pro' }}
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ env.AWS_PROD_GITHUB_OIDC_ROLE_ARN_LIQUIBASE_PRO }}
          aws-region: us-east-1

      - name: Get GitHub App token for Liquibase Pro workflow trigger
        if: ${{ matrix.build_type == 'pro' }}
        id: get-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ env.LIQUIBASE_GITHUB_APP_ID }}
          private-key: ${{ env.LIQUIBASE_GITHUB_APP_PRIVATE_KEY }}
          owner: liquibase
          repositories: liquibase-pro
          permission-contents: write
          permission-actions: write

      - name: Checkout code
        uses: actions/checkout@v5

      - name: Install jq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Get latest workflow run for branch
        if: ${{ matrix.build_type == 'oss' }}
        id: get-workflow-run
        run: |
          # Get the latest successful workflow run for the specified branch
          echo "üîç Searching for latest successful workflow run for branch: ${{ inputs.liquibaseBranch }}"

          # Get workflow runs with more detailed filtering
          WORKFLOW_RUNS_JSON=$(curl -s \
            -H "Authorization: Bearer ${{ env.LIQUIBOT_PAT_GPM_ACCESS }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/liquibase/liquibase/actions/workflows/run-tests.yml/runs?branch=${{ inputs.liquibaseBranch }}&status=completed&per_page=10")

          echo "üìä Analyzing recent workflow runs..."
          echo "$WORKFLOW_RUNS_JSON" | jq -r '.workflow_runs[] | "ID: \(.id) | Status: \(.status) | Conclusion: \(.conclusion) | Created: \(.created_at)"'

          # Find the first (most recent) workflow run with conclusion=success
          WORKFLOW_RUN=$(echo "$WORKFLOW_RUNS_JSON" | jq -r '.workflow_runs[] | select(.conclusion == "success") | .id' | head -1)

          if [ "$WORKFLOW_RUN" = "null" ] || [ -z "$WORKFLOW_RUN" ]; then
            echo "‚ùå No successful workflow run found for branch ${{ inputs.liquibaseBranch }}"
            echo "Will build using standard Dockerfile from branch source instead"
            echo "workflow_run_id=" >> $GITHUB_OUTPUT
            echo "has_workflow_run=false" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ Found latest successful workflow run ID: $WORKFLOW_RUN"
            echo "workflow_run_id=$WORKFLOW_RUN" >> $GITHUB_OUTPUT
            echo "has_workflow_run=true" >> $GITHUB_OUTPUT
          fi

      - name: Download liquibase build artifact (OSS) or from S3 (Liquibase Pro)
        id: download-artifact
        run: |
          if [[ "${{ matrix.build_type }}" == "pro" ]]; then
            echo "Downloading Liquibase Pro build from S3..."

            # Download Liquibase Pro build from S3
            LIQUIBASE_PRO_ZIP="liquibase-pro-${{ inputs.liquibaseBranch }}.zip"
            S3_URL="s3://repo.liquibase.com/releases/pro/${{ inputs.liquibaseBranch }}/$LIQUIBASE_PRO_ZIP"

            echo "Downloading from S3: $S3_URL"

            # Try to download from S3 first
            if ! aws s3 cp "$S3_URL" "$LIQUIBASE_PRO_ZIP" 2>/dev/null; then
              echo "Failed to download liquibase-pro build from S3. File may not exist yet."

              # Check if it's a 403/404 error (file doesn't exist)
              if aws s3 ls "$S3_URL" >/dev/null 2>&1; then
                echo "‚ùå File exists but access denied. Check permissions."
                exit 1
              else
                echo "üì¶ Liquibase Pro build not found in S3. Checking if we should trigger workflow or use fallback..."
                echo "trigger_liquibase_pro_workflow=true" >> $GITHUB_OUTPUT
                echo "build_ready=false" >> $GITHUB_OUTPUT
                echo "use_fallback=false" >> $GITHUB_OUTPUT
              fi
            else
              echo "‚úÖ Successfully downloaded Liquibase Pro build from S3"
              echo "trigger_liquibase_pro_workflow=false" >> $GITHUB_OUTPUT
              echo "build_ready=true" >> $GITHUB_OUTPUT
              echo "use_fallback=false" >> $GITHUB_OUTPUT

              # Extract the liquibase Pro zip
              mkdir -p liquibase-build
              unzip -q "$LIQUIBASE_PRO_ZIP" -d liquibase-build/
              echo "Liquibase Pro build extracted to liquibase-build/"
            fi

          else
            # OSS build handling
            if [[ "${{ steps.get-workflow-run.outputs.has_workflow_run }}" == "false" ]]; then
              echo "No workflow run available, will use fallback build from branch source"
              echo "build_ready=false" >> $GITHUB_OUTPUT
              echo "use_fallback=true" >> $GITHUB_OUTPUT
            else
              echo "Downloading OSS build from GitHub artifacts..."

              # Get artifact download URL
              ARTIFACT_NAME="liquibase-zip-${{ inputs.liquibaseBranch }}"
              echo "Looking for artifact: $ARTIFACT_NAME"

              ARTIFACTS_RESPONSE=$(curl -s \
                -H "Authorization: Bearer ${{ env.LIQUIBOT_PAT_GPM_ACCESS }}" \
                -H "Accept: application/vnd.github.v3+json" \
                "https://api.github.com/repos/liquibase/liquibase/actions/runs/${{ steps.get-workflow-run.outputs.workflow_run_id }}/artifacts")

              echo "Available artifacts:"
              echo "$ARTIFACTS_RESPONSE" | jq -r '.artifacts[].name'

              ARTIFACT_URL=$(echo "$ARTIFACTS_RESPONSE" | jq -r ".artifacts[] | select(.name == \"$ARTIFACT_NAME\") | .archive_download_url")

              if [ "$ARTIFACT_URL" = "null" ] || [ -z "$ARTIFACT_URL" ]; then
                echo "Artifact $ARTIFACT_NAME not found in workflow run"
                echo "Available artifacts:"
                echo "$ARTIFACTS_RESPONSE" | jq -r '.artifacts[].name'
                echo "Will use fallback build from branch source instead"
                echo "build_ready=false" >> $GITHUB_OUTPUT
                echo "use_fallback=true" >> $GITHUB_OUTPUT
              else
                echo "Downloading artifact from: $ARTIFACT_URL"

                # Download and extract artifact
                curl -L \
                  -H "Authorization: Bearer ${{ env.LIQUIBOT_PAT_GPM_ACCESS }}" \
                  -H "Accept: application/vnd.github.v3+json" \
                  -o liquibase-artifact.zip \
                  "$ARTIFACT_URL"

                # Extract the artifact
                unzip -q liquibase-artifact.zip
                echo "Artifact contents:"
                ls -la

                # Find the liquibase zip file inside the artifact
                LIQUIBASE_ZIP=$(find . -name "liquibase-*.zip" -type f | head -1)
                if [ -z "$LIQUIBASE_ZIP" ]; then
                  echo "No liquibase zip file found in artifact"
                  echo "Contents of extracted artifact:"
                  find . -type f
                  echo "Will use fallback build from branch source instead"
                  echo "build_ready=false" >> $GITHUB_OUTPUT
                  echo "use_fallback=true" >> $GITHUB_OUTPUT
                else
                  echo "Found liquibase zip: $LIQUIBASE_ZIP"

                  # Extract the liquibase zip
                  mkdir -p liquibase-build
                  unzip -q "$LIQUIBASE_ZIP" -d liquibase-build/

                  echo "Liquibase build extracted to liquibase-build/"
                  echo "build_ready=true" >> $GITHUB_OUTPUT
                  echo "use_fallback=false" >> $GITHUB_OUTPUT
                fi
              fi
            fi
          fi

          # Only show contents if build is ready
          if [[ -d "liquibase-build" ]]; then
            echo "Contents of liquibase-build:"
            ls -la liquibase-build/
          fi

      - name: Trigger Liquibase Pro Release Workflow
        if: ${{ matrix.build_type == 'pro' && steps.download-artifact.outputs.trigger_liquibase_pro_workflow == 'true' && steps.download-artifact.outputs.use_fallback != 'true' }}
        id: trigger-liquibase-pro-release
        continue-on-error: true
        uses: the-actions-org/workflow-dispatch@v4
        with:
          workflow: pro-release-to-s3.yml
          token: ${{ steps.get-token.outputs.token }}
          repo: liquibase/liquibase-pro
          inputs: '{"version": "${{ inputs.liquibaseBranch }}"}'
          ref: ${{ inputs.liquibaseBranch }}
          wait-for-completion: true
          wait-for-completion-timeout: 60m
          wait-for-completion-interval: 10m

      - name: Download Liquibase Pro build from S3 after workflow completion
        if: ${{ matrix.build_type == 'pro' && steps.download-artifact.outputs.trigger_liquibase_pro_workflow == 'true' && steps.download-artifact.outputs.use_fallback != 'true' }}
        id: download-after-trigger
        run: |
          LIQUIBASE_PRO_ZIP="liquibase-pro-${{ inputs.liquibaseBranch }}.zip"
          S3_URL="s3://repo.liquibase.com/releases/pro/${{ inputs.liquibaseBranch }}/$LIQUIBASE_PRO_ZIP"

          echo "‚¨áÔ∏è Downloading Liquibase Pro build from S3 after workflow completion..."

          if ! aws s3 cp "$S3_URL" "$LIQUIBASE_PRO_ZIP"; then
            echo "‚ùå Failed to download Liquibase Pro build even after workflow completion"
            echo "Will use fallback build from branch source instead"
            echo "build_ready=false" >> $GITHUB_OUTPUT
            echo "use_fallback=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "‚úÖ Successfully downloaded Liquibase Pro build after workflow completion"

          # Extract the liquibase Pro zip
          mkdir -p liquibase-build
          unzip -q "$LIQUIBASE_PRO_ZIP" -d liquibase-build/

          echo "Liquibase Pro build extracted to liquibase-build/"
          echo "Contents of liquibase-build:"
          ls -la liquibase-build/
          echo "build_ready=true" >> $GITHUB_OUTPUT
          echo "use_fallback=false" >> $GITHUB_OUTPUT

      - name: Validate and prepare liquibase build
        if: ${{ (matrix.build_type == 'oss' && (steps.download-artifact.outputs.build_ready == 'true' || steps.download-artifact.outputs.use_fallback == 'true')) || matrix.build_type == 'pro' }}
        id: validate-build
        run: |
          # Determine build mode
          USE_FALLBACK="false"
          if [[ "${{ matrix.build_type }}" == "oss" && "${{ steps.download-artifact.outputs.use_fallback }}" == "true" ]]; then
            USE_FALLBACK="true"
          elif [[ "${{ matrix.build_type }}" == "pro" ]]; then
            # Check for Pro fallback conditions
            if [[ "${{ steps.download-artifact.outputs.use_fallback }}" == "true" ]] || [[ "${{ steps.download-after-trigger.outputs.use_fallback }}" == "true" ]]; then
              USE_FALLBACK="true"
            # Check if Liquibase Pro workflow was triggered but failed
            elif [[ "${{ steps.download-artifact.outputs.trigger_liquibase_pro_workflow }}" == "true" ]] && [[ "${{ steps.trigger-liquibase-pro-release.outcome }}" == "failure" ]]; then
              echo "Liquibase Pro workflow trigger failed, falling back to standard Dockerfile build"
              USE_FALLBACK="true"
            # Check if Liquibase Pro workflow succeeded but download still failed (no build_ready=true from either step)
            elif [[ "${{ steps.download-artifact.outputs.trigger_liquibase_pro_workflow }}" == "true" ]] && [[ "${{ steps.download-artifact.outputs.build_ready }}" != "true" ]] && [[ "${{ steps.download-after-trigger.outputs.build_ready }}" != "true" ]]; then
              echo "Liquibase Pro workflow completed but build still not available, falling back to standard Dockerfile build"
              USE_FALLBACK="true"
            fi
          fi

          if [[ "$USE_FALLBACK" == "true" ]]; then
            echo "Using fallback mode - will build from standard Dockerfile using branch source"
            echo "use_fallback_build=true" >> $GITHUB_OUTPUT
          else
            # Validate the liquibase build structure
            if [ ! -f "liquibase-build/liquibase" ]; then
              echo "Error: liquibase executable not found in build"
              echo "Contents of liquibase-build:"
              find liquibase-build -type f
              exit 1
            fi

            # Make liquibase executable
            chmod +x liquibase-build/liquibase

            # Validate that liquibase can run
            cd liquibase-build && ./liquibase --version && cd ..

            echo "Liquibase build validation successful"
            echo "Final liquibase-build contents:"
            ls -la liquibase-build/
            echo "use_fallback_build=false" >> $GITHUB_OUTPUT
          fi

      - name: Modify Dockerfiles for artifact-based build
        if: ${{ steps.validate-build.outputs.use_fallback_build == 'false' }}
        run: |
          echo "Modifying ${{ matrix.dockerfile }} to use downloaded artifact instead of GitHub releases..."

          # Create backup
          cp "${{ matrix.dockerfile }}" "${{ matrix.dockerfile }}.backup"

          # Set version ARG based on dockerfile type
          if [[ "${{ matrix.dockerfile }}" == "DockerfilePro" ]]; then
            VERSION_ARG="LIQUIBASE_PRO_VERSION"
          else
            VERSION_ARG="LIQUIBASE_VERSION"
          fi

          # Replace version ARG with branch name
          sed -i "s/ARG ${VERSION_ARG}=.*/ARG ${VERSION_ARG}=${{ inputs.liquibaseBranch }}/" "${{ matrix.dockerfile }}"

          # Create modified Dockerfile using awk for cleaner handling
          cat "${{ matrix.dockerfile }}" | awk -v dockerfile="${{ matrix.dockerfile }}" -v branch="${{ inputs.liquibaseBranch }}" '
          BEGIN {
            in_wget_block = 0
            skip_line = 0
          }

          # Skip SHA256 ARG lines
          /^ARG LB_SHA256=/ || /^ARG LB_PRO_SHA256=/ { next }

          # Update version ARGs
          /^ARG LIQUIBASE_VERSION=/ { print "ARG LIQUIBASE_VERSION=" branch; next }
          /^ARG LIQUIBASE_PRO_VERSION=/ { print "ARG LIQUIBASE_PRO_VERSION=" branch; next }

          # Handle standard Dockerfile wget block
          dockerfile == "Dockerfile" && /^RUN wget.*package\.liquibase\.com/ {
            print "# Copy the extracted liquibase build from the build context"
            print "COPY liquibase-build/ ./"
            print ""
            print "RUN chown -R liquibase:liquibase /liquibase && \\"
            print "    ln -s /liquibase/liquibase /usr/local/bin/liquibase && \\"
            print "    ln -s /liquibase/docker-entrypoint.sh /usr/local/bin/docker-entrypoint.sh && \\"
            print "    liquibase --version"
            in_wget_block = 1
            # Skip the rest of this line and continue skipping until we find the end
            next
          }

          # Handle alpine Dockerfile wget block
          dockerfile == "Dockerfile.alpine" && /^RUN set -x/ {
            print "# Copy the extracted liquibase build from the build context"
            print "COPY liquibase-build/ ./"
            print ""
            print "RUN chown -R liquibase:liquibase /liquibase && \\"
            print "    ln -s /liquibase/liquibase /usr/local/bin/liquibase && \\"
            print "    ln -s /liquibase/docker-entrypoint.sh /usr/local/bin/docker-entrypoint.sh && \\"
            print "    liquibase --version"
            in_wget_block = 1
            next
          }

          # Handle Pro Dockerfile wget block
          dockerfile == "DockerfilePro" && /^RUN wget.*package\.liquibase\.com/ {
            print "# Copy the extracted liquibase build from the build context"
            print "COPY liquibase-build/ ./"
            print ""
            print "RUN chown -R liquibase:liquibase /liquibase && \\"
            print "    ln -s /liquibase/liquibase /usr/local/bin/liquibase && \\"
            print "    ln -s /liquibase/docker-entrypoint.sh /usr/local/bin/docker-entrypoint.sh && \\"
            print "    liquibase --version"
            in_wget_block = 1
            next
          }

          # Skip all lines in the wget block until we find the end marker
          in_wget_block == 1 {
            # Look for the end of the RUN block (line ending without backslash, and contains version check)
            if (/liquibase --version/ && !/\\$/) {
              in_wget_block = 0
            }
            next
          }

          # Print all other lines
          { print }
          ' > "${{ matrix.dockerfile }}.tmp"

          # Replace original with modified version
          mv "${{ matrix.dockerfile }}.tmp" "${{ matrix.dockerfile }}"

          echo "‚úì Modified ${{ matrix.dockerfile }}"
          echo "=== Changes made ==="
          echo "- Set ${VERSION_ARG} to ${{ inputs.liquibaseBranch }}"
          echo "- Removed wget download commands"
          echo "- Removed SHA256 checksum validation"
          echo "- Added COPY liquibase-build/ ./"

          echo ""
          echo "=== Modified Dockerfile content preview ==="
          echo "First 30 lines of modified ${{ matrix.dockerfile }}:"
          head -30 "${{ matrix.dockerfile }}"
          echo "..."

      - name: Print modified Dockerfile
        if: ${{ steps.validate-build.outputs.use_fallback_build == 'false' }}
        run: |
          echo "=== Complete modified ${{ matrix.dockerfile }} content ==="
          cat "${{ matrix.dockerfile }}"
          echo "=== End of ${{ matrix.dockerfile }} ==="

      - name: Set up Docker Buildx
        if: ${{ steps.validate-build.outcome == 'success' }}
        uses: docker/setup-buildx-action@v3

      - name: Set up QEMU
        if: ${{ steps.validate-build.outcome == 'success' }}
        uses: docker/setup-qemu-action@v3

      - name: Log in to internal Nexus Docker Registry
        if: ${{ steps.validate-build.outcome == 'success' }}
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REPO_URL }}
          username: ${{ env.REPO_USER }}
          password: ${{ env.REPO_PASSWORD }}

      - name: Build and push Docker image
        if: ${{ steps.validate-build.outcome == 'success' }}
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ${{ matrix.dockerfile }}
          push: true
          platforms: linux/amd64,linux/arm64
          provenance: false
          tags: |
            ${{ env.REPO_URL }}/${{ matrix.image_name }}:${{ inputs.liquibaseBranch }}
          labels: |
            org.opencontainers.image.source=https://github.com/liquibase/docker
            org.opencontainers.image.description=Liquibase QA Container Image${{ matrix.suffix }}
            org.opencontainers.image.licenses=Apache-2.0
            org.opencontainers.image.vendor=Liquibase
            org.opencontainers.image.version=${{ inputs.liquibaseBranch }}
            org.opencontainers.image.documentation=https://docs.liquibase.com
            org.opencontainers.image.revision=${{ github.sha }}
            liquibase.branch=${{ inputs.liquibaseBranch }}
            liquibase.build.mode=${{ steps.validate-build.outputs.use_fallback_build == 'true' && 'fallback' || 'artifact' }}
      - name: Image build summary
        if: ${{ steps.validate-build.outcome == 'success' }}
        run: |
          BUILD_MODE="${{ steps.validate-build.outputs.use_fallback_build == 'true' && 'fallback (standard Dockerfile)' || 'artifact-based' }}"
          echo "Successfully built and pushed: ${{ env.REPO_URL }}/${{ matrix.image_name }}:${{ inputs.liquibaseBranch }}"
          echo "Build mode: $BUILD_MODE"

      - name: Workflow execution summary
        if: always()
        run: |
          echo "=== QA Docker Build Workflow Summary ==="
          echo "Branch: ${{ inputs.liquibaseBranch }}"
          echo "Build Target: ${{ inputs.buildTargets }}"
          echo "Dockerfile: ${{ matrix.dockerfile }}"
          echo "Build Type: ${{ matrix.build_type }}"
          echo ""

          # Determine if fallback was used
          USE_FALLBACK="false"
          if [[ "${{ steps.validate-build.outputs.use_fallback_build }}" == "true" ]] || [[ "${{ steps.download-artifact.outputs.use_fallback }}" == "true" ]] || [[ "${{ steps.download-after-trigger.outputs.use_fallback }}" == "true" ]]; then
            USE_FALLBACK="true"
          fi

          if [[ "$USE_FALLBACK" == "true" ]]; then
            echo "üîÑ Build Mode: FALLBACK (Standard Dockerfile from branch source)"
            echo "   - No pre-built artifacts were available"
            echo "   - Used standard Dockerfile without modification"
            echo "   - Built directly from liquibase branch: ${{ inputs.liquibaseBranch }}"
          elif [[ "${{ matrix.build_type }}" == "pro" ]]; then
            if [[ "${{ steps.download-artifact.outputs.trigger_liquibase_pro_workflow }}" == "true" ]]; then
              echo "üîÑ Build Mode: ARTIFACT-BASED (Pro workflow triggered)"
              echo "   - S3 build was missing for branch ${{ inputs.liquibaseBranch }}"
              echo "   - Automatically triggered pro-release-to-s3.yml workflow"
              if [[ "${{ steps.download-after-trigger.outputs.build_ready }}" == "true" ]]; then
                echo "   - ‚úÖ Liquibase Pro workflow completed successfully"
                echo "   - ‚úÖ Liquibase Pro build downloaded and Docker image built"
              else
                echo "   - ‚ùå Liquibase Pro workflow may have failed"
                echo "   - üìã Check: https://github.com/liquibase/liquibase-pro/actions/workflows/pro-release-to-s3.yml"
              fi
            else
              echo "‚úÖ Build Mode: ARTIFACT-BASED (Direct S3 download)"
              echo "   - Liquibase Pro build downloaded from S3"
            fi
          else
            echo "‚úÖ Build Mode: ARTIFACT-BASED (GitHub artifact)"
            echo "   - OSS build downloaded from GitHub workflow artifacts"
          fi

          echo ""
          if [[ "${{ job.status }}" == "success" ]]; then
            echo "üéâ Overall Status: SUCCESS"
            echo "üì¶ Image Available: ${{ env.REPO_URL }}/${{ matrix.image_name }}:${{ inputs.liquibaseBranch }}"
            if [[ "$USE_FALLBACK" == "true" ]]; then
              echo "‚ÑπÔ∏è Built using fallback mode - standard Dockerfile from branch source"
            fi
          else
            echo "‚ùå Overall Status: FAILED"
            echo "üîç Check the logs above for detailed error information"
          fi
