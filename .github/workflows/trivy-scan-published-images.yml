# Vulnerability scanning for published Docker images using Trivy
# This workflow scans the published images on Docker Hub for vulnerabilities.
# It generates a matrix of image/tag combinations and runs Trivy scans on them.


name: Published Images Vulnerability Scanning

on:
  workflow_dispatch:
    inputs:
      max_tags_to_scan:
        description: 'Maximum number of published tags to scan'
        required: false
        default: '20'
  schedule:
      # Run Monday-Friday at 10 AM UTC (published image monitoring)
    - cron: '0 10 * * 1-5' # Run every weekday at 10am UTC

permissions:
  contents: read
  security-events: write # Required for uploading SARIF results to GitHub Security tab
  actions: read # Required for private repositories to get Action run status

jobs:
  generate-matrix:
    name: Generate Scan Matrix
    runs-on: ubuntu-22.04
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    env:
      MAX_TAGS: ${{ github.event.inputs.max_tags_to_scan || '10' }}
    steps:
      - name: Generate matrix for all image/tag combinations
        id: set-matrix
        run: |
          echo "Generating matrix for scanning with max $MAX_TAGS tags per image..."
          MATRIX_INCLUDE="["
          FIRST=true

          for IMAGE in "liquibase/liquibase" "liquibase/liquibase-secure"; do
            echo "Getting tags for $IMAGE..."
            REPO=$(basename "$IMAGE")
            TAGS=""
            URL="https://hub.docker.com/v2/namespaces/liquibase/repositories/${REPO}/tags?page_size=100"
            while [ -n "$URL" ]; do
              RESPONSE=$(curl -s "$URL")
              TAG_REGEX='^[0-9]+\.[0-9]+(\.[0-9]+)?(-alpine|-latest)?$'
              NEW_TAGS=$(echo "$RESPONSE" | jq -r '.results[] | select(.tag_status == "active") | .name' | grep -E "$TAG_REGEX" || true)
              TAGS=$(echo -e "$TAGS\n$NEW_TAGS" | sort -Vu)

              TAGS=$(echo "$TAGS" | awk '
                {
                  tags[NR] = $0
                  if (match($0, /^([0-9]+)\.([0-9]+)\.([0-9]+)(-alpine|-latest)?$/, m)) {
                    full = m[1] "." m[2] "." m[3] (m[4] ? m[4] : "")
                    has_full[full] = 1
                  }
                }
                END {
                  for (i = 1; i <= NR; i++) {
                    tag = tags[i]
                    if (match(tag, /^([0-9]+)\.([0-9]+)(-alpine|-latest)?$/, m)) {
                      short = m[1] "." m[2] ".0" (m[3] ? m[3] : "")
                      if (has_full[short]) continue
                    }
                    print tag
                  }
                }
              ')
              URL=$(echo "$RESPONSE" | jq -r '.next')
              [ "$URL" = "null" ] && break
            done

            TAGS=$(echo "$TAGS" | tac | head -n "$MAX_TAGS")
            while IFS= read -r tag; do
              if [ -n "$tag" ]; then
                if [ "$FIRST" = true ]; then
                  MATRIX_INCLUDE="${MATRIX_INCLUDE}{\"image\":\"$IMAGE\",\"tag\":\"$tag\"}"
                  FIRST=false
                else
                  MATRIX_INCLUDE="${MATRIX_INCLUDE},{\"image\":\"$IMAGE\",\"tag\":\"$tag\"}"
                fi
              fi
            done <<< "$TAGS"
          done

          MATRIX_INCLUDE="${MATRIX_INCLUDE}]"
          MATRIX="{\"include\":$MATRIX_INCLUDE}"
          echo "Generated matrix: $MATRIX"
          echo "matrix=$MATRIX" >> $GITHUB_OUTPUT

  trivy-scan:
    name: Trivy Scan ${{ matrix.image }}:${{ matrix.tag }}
    runs-on: ubuntu-22.04
    needs: generate-matrix
    permissions:
      contents: read
      security-events: write
      actions: read
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.generate-matrix.outputs.matrix) }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Pull published image
        run: |
          echo "Pulling ${{ matrix.image }}:${{ matrix.tag }}..."
          docker pull ${{ matrix.image }}:${{ matrix.tag }}

      - name: Extract nested JARs and Python packages for deep scanning
        run: |
          set -e

          # Create extraction directory
          mkdir -p /tmp/extracted-deps

          # Create container from image to extract files
          container_id=$(docker create ${{ matrix.image }}:${{ matrix.tag }})

          echo "üì¶ Extracting all Liquibase JARs for deep scanning..."

          # Extract all JAR files from /liquibase/internal directory
          echo "üîç Extracting all JAR files from container..."

          # First, check for distribution archives in /liquibase/dist
          echo "üîç Checking /liquibase/dist for tar.gz archives..."
          if docker cp $container_id:/liquibase/dist /tmp/liquibase-dist 2>/dev/null; then
            echo "‚úì Found /liquibase/dist directory"

            # Extract all tar.gz archives
            find /tmp/liquibase-dist -name "*.tar.gz" -type f | while read archive; do
              archive_name=$(basename "$archive" .tar.gz)
              echo "  üì¶ Extracting $archive_name..."
              extract_dir="/tmp/liquibase-dist/${archive_name}-extracted"
              mkdir -p "$extract_dir"
              tar -xzf "$archive" -C "$extract_dir" 2>/dev/null || true

              # Find JARs in extracted archive
              jar_count=$(find "$extract_dir" -name "*.jar" -type f | wc -l)
              if [ $jar_count -gt 0 ]; then
                echo "  ‚úì Found $jar_count JAR(s) in $archive_name"

                # Extract each JAR from the archive
                find "$extract_dir" -name "*.jar" -type f | while read jar_file; do
                  jar_name=$(basename "$jar_file" .jar)
                  jar_extract="/tmp/extracted-deps/dist/${archive_name}/${jar_name}"
                  mkdir -p "$jar_extract"
                  unzip -q "$jar_file" -d "$jar_extract" 2>/dev/null || true

                  # Check for Spring Boot nested JARs and copy them as-is (don't extract)
                  if [ -d "$jar_extract/BOOT-INF/lib" ]; then
                    echo "    ‚úì Spring Boot JAR: $jar_name - preserving nested JAR files"
                    nested_count=0
                    nested_jar_dir="/tmp/extracted-deps/dist/${archive_name}/${jar_name}-nested-jars"
                    mkdir -p "$nested_jar_dir"

                    # Create a mapping file to track parent JAR relationships
                    mapping_file="/tmp/extracted-deps/jar-mapping.txt"

                    for nested_jar in "$jar_extract/BOOT-INF/lib"/*.jar; do
                      if [ -f "$nested_jar" ]; then
                        nested_count=$((nested_count + 1))
                        nested_jar_name=$(basename "$nested_jar")

                        # Copy the JAR file as-is, don't extract it
                        cp "$nested_jar" "$nested_jar_dir/" 2>/dev/null || true

                        # Record the parent ‚Üí nested relationship
                        echo "${jar_name}.jar ‚Üí $nested_jar_name" >> "$mapping_file"
                      fi
                    done
                    echo "      ‚Üí Preserved $nested_count nested JAR file(s)"
                  fi
                done
              fi
            done
          else
            echo "‚ö† No /liquibase/dist directory found"
          fi

          # Copy entire internal directory for comprehensive scanning
          if docker cp $container_id:/liquibase/internal /tmp/liquibase-internal 2>/dev/null; then
            echo "‚úì Copied /liquibase/internal directory"

            # Count total JARs
            jar_count=$(find /tmp/liquibase-internal -name "*.jar" -type f | wc -l)
            echo "üìä Found $jar_count JAR files to scan"

            # Copy all JAR files preserving them for Trivy to scan
            mkdir -p /tmp/extracted-deps/internal-jars/lib
            mkdir -p /tmp/extracted-deps/internal-jars/extensions
            jar_num=0

            # Copy lib JARs as-is
            if [ -d /tmp/liquibase-internal/lib ]; then
              cp /tmp/liquibase-internal/lib/*.jar /tmp/extracted-deps/internal-jars/lib/ 2>/dev/null || true
              lib_jar_count=$(ls -1 /tmp/extracted-deps/internal-jars/lib/*.jar 2>/dev/null | wc -l)
              echo "  ‚úì Preserved $lib_jar_count lib JAR(s)"
            fi

            # Copy extension JARs as-is
            if [ -d /tmp/liquibase-internal/extensions ]; then
              cp /tmp/liquibase-internal/extensions/*.jar /tmp/extracted-deps/internal-jars/extensions/ 2>/dev/null || true
              ext_jar_count=$(ls -1 /tmp/extracted-deps/internal-jars/extensions/*.jar 2>/dev/null | wc -l)
              echo "  ‚úì Preserved $ext_jar_count extension JAR(s)"
            fi

            echo "‚úì Preserved $jar_count JAR files for scanning"
          else
            echo "‚ö† Could not copy /liquibase/internal directory"
          fi

          # Extract liquibase-checks.jar (contains GraalVM Python embedded dependencies)
          if docker cp $container_id:/liquibase/internal/extensions/liquibase-checks.jar /tmp/liquibase-checks.jar 2>/dev/null; then
            echo "‚úì Found liquibase-checks.jar"
            mkdir -p /tmp/extracted-deps/checks
            unzip -q /tmp/liquibase-checks.jar -d /tmp/extracted-deps/checks || true

            # Extract GraalVM Python packages to standard Python structure
            if [ -d /tmp/extracted-deps/checks/org.graalvm.python.vfs ]; then
              echo "‚úì Extracting GraalVM Python packages..."
              mkdir -p /tmp/extracted-deps/python-packages

              # Copy from both possible locations
              if [ -d /tmp/extracted-deps/checks/org.graalvm.python.vfs/venv/lib/python3.11/site-packages ]; then
                cp -r /tmp/extracted-deps/checks/org.graalvm.python.vfs/venv/lib/python3.11/site-packages/* /tmp/extracted-deps/python-packages/ 2>/dev/null || true
              fi
              if [ -d /tmp/extracted-deps/checks/org.graalvm.python.vfs/venv/Lib/site-packages ]; then
                cp -r /tmp/extracted-deps/checks/org.graalvm.python.vfs/venv/Lib/site-packages/* /tmp/extracted-deps/python-packages/ 2>/dev/null || true
              fi

              # Also extract bundled wheels
              if [ -d /tmp/extracted-deps/checks/META-INF/resources/libpython/ensurepip/_bundled ]; then
                mkdir -p /tmp/extracted-deps/python-bundled
                cp /tmp/extracted-deps/checks/META-INF/resources/libpython/ensurepip/_bundled/*.whl /tmp/extracted-deps/python-bundled/ 2>/dev/null || true
              fi
            fi
          else
            echo "‚ö† liquibase-checks.jar not found"
          fi

          # Cleanup container
          docker rm $container_id

          # Show what was extracted
          echo ""
          echo "üìä Extraction Summary:"
          total_files=$(find /tmp/extracted-deps -type f 2>/dev/null | wc -l)
          echo "Total files extracted: $total_files"

          if [ -d /tmp/extracted-deps/dist ]; then
            dist_archives=$(find /tmp/liquibase-dist -name "*.tar.gz" -type f 2>/dev/null | wc -l)
            dist_jars=$(find /tmp/liquibase-dist -name "*.jar" -type f 2>/dev/null | wc -l)
            nested_jars=$(find /tmp/extracted-deps/dist -type d -name "*-nested-jars" -exec sh -c 'ls -1 "{}"/*.jar 2>/dev/null | wc -l' \; 2>/dev/null | awk '{s+=$1} END {print s}')
            echo "Distribution archives: $dist_archives"
            echo "  - JARs in archives: $dist_jars"
            if [ "$nested_jars" -gt 0 ]; then
              echo "  - Spring Boot nested JARs: $nested_jars"
            fi
          fi

          if [ -d /tmp/extracted-deps/internal-jars ]; then
            lib_jars=$(ls -1 /tmp/extracted-deps/internal-jars/lib/*.jar 2>/dev/null | wc -l)
            ext_jars=$(ls -1 /tmp/extracted-deps/internal-jars/extensions/*.jar 2>/dev/null | wc -l)
            total_internal=$((lib_jars + ext_jars))
            echo "Internal JARs preserved: $total_internal"
            echo "  - Lib JARs: $lib_jars"
            echo "  - Extension JARs: $ext_jars"
          fi

          if [ -d /tmp/extracted-deps/python-packages ]; then
            python_pkgs=$(ls -1 /tmp/extracted-deps/python-packages 2>/dev/null | grep -E '\.(dist-info|egg-info)$' | wc -l)
            echo "Python packages found: $python_pkgs"
          fi

      - name: Generate SBOM with Syft
        uses: anchore/sbom-action@v0
        with:
          image: '${{ matrix.image }}:${{ matrix.tag }}'
          format: 'spdx-json'
          output-file: 'sbom.spdx.json'

      - name: Run Trivy vulnerability scanner (Surface Scan)
        id: trivy_scan
        uses: aquasecurity/trivy-action@0.33.1
        with:
          image-ref: '${{ matrix.image }}:${{ matrix.tag }}'
          vuln-type: 'os,library'
          scanners: 'vuln'
          format: 'json'
          output: 'trivy-surface.json'
          severity: 'HIGH,CRITICAL'
          exit-code: '0'
        continue-on-error: true

      - name: Run Trivy scanner on extracted nested JARs (Deep Scan)
        id: trivy_deep
        uses: aquasecurity/trivy-action@0.33.1
        with:
          scan-type: 'rootfs'
          scan-ref: '/tmp/extracted-deps'
          vuln-type: 'library'
          format: 'json'
          output: 'trivy-deep.json'
          severity: 'HIGH,CRITICAL'
          exit-code: '0'
        continue-on-error: true

      - name: Run Grype scanner on SBOM
        id: grype_scan
        uses: anchore/scan-action@v5
        with:
          sbom: 'sbom.spdx.json'
          fail-build: false
          severity-cutoff: high
          output-format: json
        continue-on-error: true

      - name: Save Grype results to file
        if: always()
        run: |
          # The anchore/scan-action outputs to stdout, capture it
          # Check for Grype output files in various possible locations
          if [ -f "results.json" ]; then
            mv results.json grype-results.json
            echo "‚úì Grype JSON results saved to grype-results.json"
          elif [ -f "anchore-scan-results.json" ]; then
            mv anchore-scan-results.json grype-results.json
            echo "‚úì Grype JSON results saved to grype-results.json"
          else
            echo "‚ö† Grype JSON output file not found in expected locations"
            echo "Checking for any JSON files created by Grype:"
            find . -name "*.json" -type f -mmin -5 | grep -v node_modules || true
          fi

        # trivy convert steps assume trivy CLI is available, therefore install the CLI before using those commands across steps.
      - name: Install Trivy CLI
        run: |
            curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin
            trivy --version

      - name: Convert JSON to SARIF and analyze results
        if: always()
        run: |
          set +e  # Don't fail immediately

          echo "üîç Converting scan results to SARIF format..."
          echo ""
          echo "Available scan result files:"
          ls -lh *.sarif *.json 2>/dev/null || echo "No scan result files found"
          echo ""

          # Convert Trivy surface scan results
          if [ -f trivy-surface.json ]; then
            trivy convert --format sarif --output trivy-surface.sarif trivy-surface.json
            surface_vulns=$(jq '[.Results[]?.Vulnerabilities[]? | select(.Severity == "HIGH" or .Severity == "CRITICAL")] | length' trivy-surface.json 2>/dev/null || echo 0)
            echo "‚úì Trivy Surface Scan: $surface_vulns HIGH/CRITICAL vulnerabilities"
          else
            surface_vulns=0
            echo "‚ö† Trivy Surface Scan: JSON file not found"
          fi

          # Convert Trivy deep scan results
          if [ -f trivy-deep.json ]; then
            trivy convert --format sarif --output trivy-deep.sarif trivy-deep.json
            deep_vulns=$(jq '[.Results[]?.Vulnerabilities[]? | select(.Severity == "HIGH" or .Severity == "CRITICAL")] | length' trivy-deep.json 2>/dev/null || echo 0)
            echo "‚úì Trivy Deep Scan: $deep_vulns HIGH/CRITICAL vulnerabilities"
          else
            deep_vulns=0
            echo "‚ö† Trivy Deep Scan: JSON file not found"
          fi

          # Process Grype results
          if [ -f grype-results.json ]; then
            # Grype scan-action already outputs SARIF if specified
            # Count vulnerabilities from JSON
            grype_vulns=$(jq '[.matches[]? | select(.vulnerability.severity == "High" or .vulnerability.severity == "Critical")] | length' grype-results.json 2>/dev/null || echo 0)
            echo "‚úì Grype SBOM Scan: $grype_vulns HIGH/CRITICAL vulnerabilities"
          else
            grype_vulns=0
            echo "‚ö† Grype SBOM Scan: JSON file not found (scan may have failed or SBOM was empty)"
          fi

          total_vulns=$((surface_vulns + deep_vulns + grype_vulns))
          echo ""
          echo "üìä Total HIGH/CRITICAL vulnerabilities found: $total_vulns"

          # Print detailed table if vulnerabilities found
          if [ $total_vulns -gt 0 ]; then
            echo ""
            echo "==== Trivy Surface Scan Vulnerabilities ===="
            if [ -f trivy-surface.json ] && [ $surface_vulns -gt 0 ]; then
              trivy convert --format table trivy-surface.json
            fi

            echo ""
            echo "==== Trivy Deep Scan Vulnerabilities (Nested JARs) ===="
            if [ -f trivy-deep.json ] && [ $deep_vulns -gt 0 ]; then
              trivy convert --format table trivy-deep.json
            fi
          fi

          # Store counts for later use
          echo "surface_vulns=$surface_vulns" >> $GITHUB_ENV
          echo "deep_vulns=$deep_vulns" >> $GITHUB_ENV
          echo "grype_vulns=$grype_vulns" >> $GITHUB_ENV
          echo "total_vulns=$total_vulns" >> $GITHUB_ENV

      - name: Create enhanced vulnerability report with parent JAR mapping
        if: always()
        run: |
          report_file="vulnerability-report-enhanced.md"

          {
            echo "# Enhanced Vulnerability Report"
            echo ""
            echo "**Image**: \`${{ matrix.image }}:${{ matrix.tag }}\`"
            echo "**Scan Date**: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
            echo ""
            echo "## Summary"
            echo ""
            echo "| Scanner | HIGH/CRITICAL Vulnerabilities |"
            echo "|---------|-------------------------------|"
            echo "| Trivy Surface (OS + Top-level) | ${surface_vulns:-0} |"
            echo "| Trivy Deep (Nested JARs + Python) | ${deep_vulns:-0} |"
            echo "| Grype (SBOM-based) | ${grype_vulns:-0} |"
            echo "| **Total** | **${total_vulns:-0}** |"
            echo ""
          } > "$report_file"

          # Add parent JAR mapping section
          if [ -f /tmp/extracted-deps/jar-mapping.txt ]; then
            {
              echo "## Parent JAR Relationships"
              echo ""
              echo "The following shows which Liquibase JARs contain vulnerable nested dependencies:"
              echo ""
              echo "\`\`\`"
              cat /tmp/extracted-deps/jar-mapping.txt | sort | uniq
              echo "\`\`\`"
              echo ""
            } >> "$report_file"
          fi

          # Add detailed vulnerability table with parent JAR context
          if [ -f trivy-deep.json ]; then
            {
              echo "## Detailed Vulnerability Analysis"
              echo ""
              echo "### Nested JAR Vulnerabilities"
              echo ""
              echo "| Parent JAR | Nested JAR | Vulnerability | Severity | Installed | Fixed |"
              echo "|------------|------------|---------------|----------|-----------|-------|"
            } >> "$report_file"

            # Process each vulnerability and match with parent JAR
            jq -r '.Results[]? | .Target as $target | .Vulnerabilities[]? |
              select(.Severity == "HIGH" or .Severity == "CRITICAL") |
              "\($target)|\(.PkgName)|\(.VulnerabilityID)|\(.Severity)|\(.InstalledVersion)|\(.FixedVersion // "-")"' \
              trivy-deep.json 2>/dev/null | while IFS='|' read -r target pkg vuln severity installed fixed; do

              # Extract JAR name from target path
              jar_file=$(basename "$target" 2>/dev/null || echo "$target")

              # Find parent JAR from mapping file
              if [ -f /tmp/extracted-deps/jar-mapping.txt ]; then
                parent_jar=$(grep "$jar_file" /tmp/extracted-deps/jar-mapping.txt | cut -d'‚Üí' -f1 | tr -d ' ' | head -1)
                if [ -z "$parent_jar" ]; then
                  parent_jar="(internal)"
                fi
              else
                parent_jar="(unknown)"
              fi

              echo "| $parent_jar | $jar_file | $vuln | $severity | $installed | $fixed |" >> "$report_file"
            done

            echo "" >> "$report_file"
          fi

          # Add Python vulnerabilities
          if [ -f trivy-deep.json ]; then
            python_vulns=$(jq '[.Results[]? | select(.Type == "python-pkg") | .Vulnerabilities[]? | select(.Severity == "HIGH" or .Severity == "CRITICAL")] | length' trivy-deep.json 2>/dev/null || echo 0)

            if [ "$python_vulns" -gt 0 ]; then
              {
                echo "### Python Package Vulnerabilities"
                echo ""
                echo "These are found in \`liquibase-checks.jar\` (GraalVM Python VFS)"
                echo ""
                echo "| Package | Vulnerability | Severity | Installed | Fixed |"
                echo "|---------|---------------|----------|-----------|-------|"
              } >> "$report_file"

              jq -r '.Results[]? | select(.Type == "python-pkg") | .Vulnerabilities[]? |
                select(.Severity == "HIGH" or .Severity == "CRITICAL") |
                "\(.PkgName)|\(.VulnerabilityID)|\(.Severity)|\(.InstalledVersion)|\(.FixedVersion // "-")"' \
                trivy-deep.json 2>/dev/null | while IFS='|' read -r pkg vuln severity installed fixed; do
                echo "| $pkg | $vuln | $severity | $installed | $fixed |" >> "$report_file"
              done

              echo "" >> "$report_file"
            fi
          fi

          echo "‚úì Enhanced vulnerability report created: $report_file"

      - name: Upload enhanced vulnerability report
        if: always()
        uses: actions/upload-artifact@v5
        with:
          name: vulnerability-report-${{ matrix.image == 'liquibase/liquibase-secure' && 'secure' || 'community' }}-${{ matrix.tag }}
          path: vulnerability-report-enhanced.md
          retention-days: 90

      - name: Upload Trivy Surface SARIF to GitHub Security tab
        if: always()
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: 'trivy-surface.sarif'
          category: 'trivy-${{ matrix.image }}-${{ matrix.tag }}-surface'
        continue-on-error: true

      - name: Check if Trivy Deep SARIF exists
        if: always()
        id: check_trivy_deep
        run: |
          if [ -f "trivy-deep.sarif" ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Upload Trivy Deep SARIF to GitHub Security tab
        if: always() && steps.check_trivy_deep.outputs.exists == 'true'
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: 'trivy-deep.sarif'
          category: 'trivy-${{ matrix.image }}-${{ matrix.tag }}-deep'
        continue-on-error: true

      - name: Check if Grype SARIF exists
        if: always()
        id: check_grype
        run: |
          if [ -f "grype-results.sarif" ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Upload Grype SARIF to GitHub Security tab
        if: always() && steps.check_grype.outputs.exists == 'true'
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: 'grype-results.sarif'
          category: 'trivy-${{ matrix.image }}-${{ matrix.tag }}-grype'
        continue-on-error: true

      - name: Set sanitized names for artifacts
        if: always()
        id: sanitize
        run: |
          SANITIZED_IMAGE=$(echo "${{ matrix.image }}" | tr '/' '-')
          SANITIZED_TAG=$(echo "${{ matrix.tag }}" | tr '/' '-' | tr ':' '-' | tr '.' '-')
          echo "image=$SANITIZED_IMAGE" >> $GITHUB_OUTPUT
          echo "tag=$SANITIZED_TAG" >> $GITHUB_OUTPUT

      - name: Upload Scan Results as Artifacts
        if: always()
        uses: actions/upload-artifact@v5
        with:
          name: security-report-${{ steps.sanitize.outputs.image }}-${{ steps.sanitize.outputs.tag }}
          path: |
            trivy-surface.json
            trivy-surface.sarif
            trivy-deep.json
            trivy-deep.sarif
            grype-results.json
            sbom.spdx.json
          if-no-files-found: ignore

      - name: Fail job if vulnerabilities found
        run: |
          if [ "${{ env.total_vulns }}" -gt 0 ]; then
            echo "‚ùå Found ${{ env.total_vulns }} HIGH/CRITICAL vulnerabilities in ${{ matrix.image }}:${{ matrix.tag }}"
            echo "  - Surface scan: ${{ env.surface_vulns }} vulnerabilities"
            echo "  - Deep scan (nested JARs): ${{ env.deep_vulns }} vulnerabilities"
            echo "  - Grype SBOM scan: ${{ env.grype_vulns }} vulnerabilities"
            echo ""
            echo "Check the logs above for detailed vulnerability information"
            exit 1
          else
            echo "‚úÖ No HIGH/CRITICAL vulnerabilities found in ${{ matrix.image }}:${{ matrix.tag }}"
          fi
      
      - name: Append summary to GitHub Actions summary
        if: always()
        run: |
          {
            echo "## üõ°Ô∏è Vulnerability Scan Results for \`${{ matrix.image }}:${{ matrix.tag }}\`"
            echo ""
            echo "**Total HIGH/CRITICAL Vulnerabilities: ${{ env.total_vulns }}**"
            echo ""
            echo "| Scanner | Vulnerabilities | Status |"
            echo "|---------|-----------------|--------|"
            echo "| üîç Trivy Surface (OS + Top-level) | ${{ env.surface_vulns }} | $([ ${{ env.surface_vulns }} -eq 0 ] && echo '‚úÖ' || echo '‚ö†Ô∏è') |"
            echo "| üîé Trivy Deep (Nested JARs + Python) | ${{ env.deep_vulns }} | $([ ${{ env.deep_vulns }} -eq 0 ] && echo '‚úÖ' || echo '‚ö†Ô∏è') |"
            echo "| üìã Grype (SBOM-based) | ${{ env.grype_vulns }} | $([ ${{ env.grype_vulns }} -eq 0 ] && echo '‚úÖ' || echo '‚ö†Ô∏è') |"
            echo ""
          } >> $GITHUB_STEP_SUMMARY

          # Add detailed vulnerability tables
          if [ ${{ env.surface_vulns }} -gt 0 ] && [ -f trivy-surface.json ]; then
            {
              echo "### üîç Trivy Surface Scan Details"
              echo ""
              echo "| Package | Vulnerability | Severity | Installed | Fixed |"
              echo "|---------|---------------|----------|-----------|-------|"
            } >> $GITHUB_STEP_SUMMARY

            jq -r '.Results[]?.Vulnerabilities[]? | select(.Severity == "HIGH" or .Severity == "CRITICAL") |
              "| \(.PkgName) | \(.VulnerabilityID) | \(.Severity) | \(.InstalledVersion) | \(.FixedVersion // "-") |"' \
              trivy-surface.json 2>/dev/null | head -20 >> $GITHUB_STEP_SUMMARY || echo "| Error parsing results | - | - | - | - |" >> $GITHUB_STEP_SUMMARY

            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          if [ ${{ env.deep_vulns }} -gt 0 ] && [ -f trivy-deep.json ]; then
            {
              echo "### üîé Trivy Deep Scan Details (Nested JARs & Python)"
              echo ""
              echo "| Parent JAR | Package | Vulnerability | Severity | Installed | Fixed |"
              echo "|------------|---------|---------------|----------|-----------|-------|"
            } >> $GITHUB_STEP_SUMMARY

            # Process each vulnerability and look up parent JAR from mapping file
            jq -r '.Results[]? | .Target as $target | .Vulnerabilities[]? |
              select(.Severity == "HIGH" or .Severity == "CRITICAL") |
              "\($target)|\(.PkgName)|\(.VulnerabilityID)|\(.Severity)|\(.InstalledVersion)|\(.FixedVersion // "-")"' \
              trivy-deep.json 2>/dev/null | head -30 | while IFS='|' read -r target pkg vuln severity installed fixed; do

              # Extract JAR filename from target path
              jar_file=$(basename "$target" 2>/dev/null || echo "$target")

              # Look up parent JAR from mapping file
              if [ -f /tmp/extracted-deps/jar-mapping.txt ]; then
                parent_jar=$(grep "$jar_file" /tmp/extracted-deps/jar-mapping.txt 2>/dev/null | cut -d'‚Üí' -f1 | tr -d ' ' | head -1)
                if [ -z "$parent_jar" ]; then
                  parent_jar="(internal)"
                fi
              else
                parent_jar="(unknown)"
              fi

              echo "| $parent_jar | $pkg | $vuln | $severity | $installed | $fixed |" >> $GITHUB_STEP_SUMMARY
            done

            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          if [ ${{ env.grype_vulns }} -gt 0 ] && [ -f grype-results.json ]; then
            {
              echo "### üìã Grype SBOM Scan Details"
              echo ""
              echo "| Package | Vulnerability | Severity | Installed | Fixed |"
              echo "|---------|---------------|----------|-----------|-------|"
            } >> $GITHUB_STEP_SUMMARY

            jq -r '.matches[]? | select(.vulnerability.severity == "High" or .vulnerability.severity == "Critical") |
              "| \(.artifact.name) | \(.vulnerability.id) | \(.vulnerability.severity) | \(.artifact.version) | \(.vulnerability.fix.versions[0] // "-") |"' \
              grype-results.json 2>/dev/null | head -20 >> $GITHUB_STEP_SUMMARY || echo "| Error parsing results | - | - | - | - |" >> $GITHUB_STEP_SUMMARY

            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          # Add scanner information
          {
            echo "---"
            echo ""
            echo "### üìñ Scanner Information"
            echo ""
            echo "- **Trivy Surface**: Scans OS packages and top-level libraries"
            echo "- **Trivy Deep**: Extracts and scans nested Spring Boot JARs (BOOT-INF/lib) and GraalVM Python packages"
            echo "- **Grype**: SBOM-based validation for comprehensive dependency analysis"
            echo ""
            echo "üí° **Note**: Deep scan detects vulnerabilities in nested dependencies that standard scans miss."
          } >> $GITHUB_STEP_SUMMARY

  notify-results:
    name: Notify Scan Results
    runs-on: ubuntu-22.04
    needs: [trivy-scan, generate-matrix]
    if: always()
    strategy:
     matrix:
        image: ["liquibase/liquibase", "liquibase/liquibase-secure"]
    steps:
      - name: "Check failures for ${{ matrix.image }}"
        id: check_failures
        uses: actions/github-script@v8
        with:
            script: |
                const image = '${{ matrix.image }}';
                const jobs = await github.rest.actions.listJobsForWorkflowRun({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    run_id: context.runId
                });

                const scanJobs = jobs.data.jobs.filter(job =>
                    job.name.includes(`Trivy Scan ${image}`)
                );

                const failed = scanJobs.filter(job => job.conclusion === 'failure');
                const failedCount = failed.length;
                const totalCount = scanJobs.length;

                core.setOutput('has_failures', failedCount > 0);
                core.setOutput('failed_count', failedCount.toString());
                core.setOutput('total_count', totalCount.toString());

## Since we only fix forward, this Slack notification is redundant.
## It reports vulnerabilities in outdated images even though they've already been fixed.

      # - name: "Notify Slack for ${{ matrix.image }}"
        # if: steps.check_failures.outputs.has_failures == 'true'
        # uses: rtCamp/action-slack-notify@v2
        # env:
        #     SLACK_COLOR: 'danger'
        #     SLACK_MESSAGE: "Security vulnerabilities found in ${{ steps.check_failures.outputs.failed_count }} out of ${{ steps.check_failures.outputs.total_count }} tags for *${{ matrix.image }}*.\nüîé [View Workflow Run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})"
        #     SLACK_TITLE: "‚ùå Trivy scan found vulnerabilities in ${{ matrix.image }}"
        #     SLACK_USERNAME: liquibot
        #     SLACK_WEBHOOK: ${{ secrets.DOCKER_SLACK_WEBHOOK_URL }}
        #     SLACK_ICON_EMOJI: ":warning:"
        #     SLACK_FOOTER: "${{ github.repository }} - ${{ matrix.image }}"
        #     SLACK_LINK_NAMES: true
