# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

name: Test Dockerfiles

on:
  push:
    branches: ["main", "master"]
  pull_request:
    # The branches below must be a subset of the branches above
    branches: ["main"]

permissions:
  contents: read
  id-token: write

jobs:
  test:
    env:
      CONTAINER_NAME: "liquibase"

    strategy:
      fail-fast: false
      matrix:
        dockerfile: [Dockerfile, Dockerfile.alpine, DockerfilePro]
        os: [ubuntu-latest, macos-13]

    name: Build & Test ${{ matrix.dockerfile }} - ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Docker on macOS
        if: matrix.os == 'macos-13'
        uses: douglascamata/setup-docker-macos-action@v1.0.0
            
      - name: Build an image from ${{ matrix.dockerfile }}
        run: |
          docker build -f ${{ matrix.dockerfile }} -t liquibase/liquibase:${{ github.sha }} .

      - name: Configure AWS credentials for vault access
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.LIQUIBASE_VAULT_OIDC_ROLE_ARN }}
          aws-region: us-east-1

      - name: Get secrets from vault
        id: vault-secrets
        uses: aws-actions/aws-secretsmanager-get-secrets@v2
        with:
          secret-ids: |
            ,/vault/liquibase
          parse-json-secrets: true

      - name: Test liquibase init start-h2
        run: |
          LOG_STRING="The database does not persist data"
          docker run --env LIQUIBASE_LICENSE_KEY=${{ env.PRO_LICENSE_KEY }} --name $CONTAINER_NAME -d -v $(pwd)/.github/test:/liquibase/changelog liquibase/liquibase:${{ github.sha }} init start-h2
          sleep 30
          # Check if the container is running
          if docker inspect -f '{{.State.Running}}' "$CONTAINER_NAME" 2>/dev/null | grep -q "true"; then
              # Get the logs and check if the desired string is present
              if docker logs "$CONTAINER_NAME" 2>&1 | grep -q "$LOG_STRING"; then
                  echo "The log contains the string: $LOG_STRING"
              else
                  echo "The log does not contain the string: $LOG_STRING"
                  exit 1
              fi
          else
              echo "Error: Container $CONTAINER_NAME is not running."
              exit 2
          fi

      - name: Test liquibase version
        run: |
          LOG_STRING="Starting Liquibase"
          # Check if the container is running
          if docker inspect -f '{{.State.Running}}' "$CONTAINER_NAME" 2>/dev/null | grep -q "true"; then
              # Get the logs and check if the desired string is present
              if docker exec $CONTAINER_NAME liquibase --version 2>&1 | grep -q "$LOG_STRING"; then
                  echo "The log contains the string: $LOG_STRING"
              else
                  echo "The log does not contain the string: $LOG_STRING"
                  exit 1
              fi
          else
              echo "Error: Container $CONTAINER_NAME is not running."
              exit 2
          fi

      - name: Test liquibase update
        run: |
          LOG_STRING="Update has been successful"
          # Check if the container is running
          if docker inspect -f '{{.State.Running}}' "$CONTAINER_NAME" 2>/dev/null | grep -q "true"; then
              # Get the logs and check if the desired string is present
              if docker exec $CONTAINER_NAME liquibase update --defaultsFile=/liquibase/changelog/liquibase.properties --changelog-file=/changelog/example-changelog.xml 2>&1 | grep -q "$LOG_STRING"; then
                  echo "The log contains the string: $LOG_STRING"
              else
                  echo "The log does not contain the string: $LOG_STRING"
                  exit 1
              fi
          else
              echo "Error: Container $CONTAINER_NAME is not running."
              exit 2
          fi

      - name: Test liquibase wrong ENV variable
        run: |
          LOG_STRING="Error: Unable to access jarfile wrong_path/internal/lib/"
          # Stop docker container and remove it
          docker stop $CONTAINER_NAME
          docker rm $CONTAINER_NAME
          # Start docker container with wrong ENV
          # Get the logs and check if the desired string is present
          if docker run --env LIQUIBASE_LICENSE_KEY=${{ env.PRO_LICENSE_KEY }} --name $CONTAINER_NAME -d -v $(pwd)/.github/test:/liquibase/changelog -e LIQUIBASE_HOME="wrong_path" liquibase/liquibase:${{ github.sha }} init start-h2 2>&1 | grep -q "$LOG_STRING"; then
            echo "The log does not contain the string: $LOG_STRING"
            exit 1
          else
            echo "The log contains the string: $LOG_STRING"
          fi

      - name: Test liquibase good ENV variable
        run: |
          LOG_STRING="The database does not persist data"
          # Stop docker container and remove it
          docker stop $CONTAINER_NAME
          docker rm $CONTAINER_NAME
          # Start docker container with good ENV
          docker run --env LIQUIBASE_LICENSE_KEY=${{ env.PRO_LICENSE_KEY }} --name $CONTAINER_NAME -d -v $(pwd)/.github/test:/liquibase/changelog -e LIQUIBASE_HOME="/liquibase" liquibase/liquibase:${{ github.sha }} init start-h2
          sleep 30
          docker logs $CONTAINER_NAME
          # Check if the container is running
          if docker inspect -f '{{.State.Running}}' "$CONTAINER_NAME" 2>/dev/null | grep -q "true"; then
              # Get the logs and check if the desired string is present
              if docker logs "$CONTAINER_NAME" 2>&1 | grep -q "$LOG_STRING"; then
                  echo "The log contains the string: $LOG_STRING"
              else
                  echo "The log does not contain the string: $LOG_STRING"
                  exit 1
              fi
          else
              echo "Error: Container $CONTAINER_NAME is not running."
              exit 2
          fi

      - name: Test volume persistence
        run: |
          LOG_STRING="Update has been successful"
          # Stop docker container
          docker stop $CONTAINER_NAME
          # Start docker container
          docker start $CONTAINER_NAME
          sleep 30
          # Check if the container is running
          if docker inspect -f '{{.State.Running}}' "$CONTAINER_NAME" 2>/dev/null | grep -q "true"; then
              # Get the logs and check if the desired string is present
              if docker exec $CONTAINER_NAME liquibase update --defaultsFile=/liquibase/changelog/liquibase.properties --changelog-file=/changelog/example-changelog.xml 2>&1 | grep -q "$LOG_STRING"; then
                  echo "The log contains the string: $LOG_STRING"
              else
                  echo "The log does not contain the string: $LOG_STRING"
                  exit 1
              fi
          else
              echo "Error: Container $CONTAINER_NAME is not running."
              exit 2
          fi

      - name: Test extension loading
        run: |
          LOG_STRING="liquibase-redshift"
          # Stop docker container
          docker exec $CONTAINER_NAME lpm add liquibase-redshift --category=extension -g
          # Get the logs and check if the desired string is present
          if docker exec $CONTAINER_NAME liquibase --version 2>&1 | grep -q "$LOG_STRING"; then
              echo "The log contains the string: $LOG_STRING"
          else
              echo "The log does not contain the string: $LOG_STRING"
              exit 1
          fi

      - name: Test driver connection
        run: |
          LOG_STRING="successfully installed in classpath"
          docker stop $CONTAINER_NAME
          docker rm $CONTAINER_NAME
          docker network create --driver bridge test_network
          # Get the logs and check if the desired string is present
          docker run -d --env LIQUIBASE_LICENSE_KEY=${{ env.PRO_LICENSE_KEY }} --name $CONTAINER_NAME --network test_network -v $(pwd)/.github/test:/liquibase/changelog liquibase/liquibase:${{ github.sha }} init start-h2
          if docker exec $CONTAINER_NAME lpm add mssql --category=driver -g 2>&1 | grep -q "$LOG_STRING"; then
              echo "The log contains the string: $LOG_STRING"
          else
              echo "The log does not contain the string: $LOG_STRING"
              exit 1
          fi

      - name: Test custom entrypoint
        run: |
          LOG_STRING="Update has been successful"
          # Build auxiliary liquibase image to inherit from
          docker build -f ${{ matrix.dockerfile }} -t liquibase:test-entrypoint .
          # Build custom liquibase image
          docker build -f $(pwd)/.github/test/Dockerfile -t liquibase:test $(pwd)/.github/test/
          # Get the logs and check if the desired string is present
          docker run --rm --env LIQUIBASE_LICENSE_KEY=${{ env.PRO_LICENSE_KEY }} --name liquibase-test --entrypoint="/scripts/liquibase_command.sh" -v $(pwd)/.github/test:/liquibase/changelog liquibase:test "version"

      # CLI-Docker Compatibility Feature Tests
      - name: Test CLI-Docker compatibility - Working directory change
        run: |
          echo "Testing that working directory changes to /liquibase/changelog when mounted..."
          
          # Stop and remove existing container
          docker stop $CONTAINER_NAME || true
          docker rm $CONTAINER_NAME || true
          
          # Create test directory with a properties file to verify working directory
          mkdir -p test-compatibility
          cat > test-compatibility/test.properties << EOF
          changelogFile=test-changelog.xml
          url=offline:postgresql
          driver=org.postgresql.Driver
          EOF
          
          cat > test-compatibility/test-changelog.xml << 'EOF'
          <?xml version="1.0" encoding="UTF-8"?>
          <databaseChangeLog xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
                             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                             xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
                             http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.8.xsd">
              <changeSet id="1" author="test">
                  <sql>SELECT 'Test';</sql>
              </changeSet>
          </databaseChangeLog>
          EOF
          
          # Test that working directory changes when /liquibase/changelog is mounted
          # If working directory changed, it should find test.properties with relative path
          RESULT=$(docker run --rm --env LIQUIBASE_LICENSE_KEY=${{ env.PRO_LICENSE_KEY }} -v $(pwd)/test-compatibility:/liquibase/changelog \
            liquibase/liquibase:${{ github.sha }} \
            --defaultsFile=test.properties validate 2>&1)
          
          echo "Container output: $RESULT"
          
          # If working directory changed correctly, validation should succeed
          if echo "$RESULT" | grep -q "No validation errors found"; then
            echo "✅ SUCCESS: Working directory correctly changed to mounted changelog directory"
          else
            echo "❌ FAIL: Working directory did not change to changelog directory or validation failed"
            echo "This indicates the properties file was not found with relative path"
            exit 1
          fi
          
          # Cleanup
          rm -rf test-compatibility

      - name: Test CLI-Docker compatibility - Relative path file creation  
        run: |
          echo "Testing relative path file creation with new CLI-Docker compatibility..."
          
          # Create test directory structure
          mkdir -p test-file-creation
          cat > test-file-creation/test-changelog.xml << 'EOF'
          <?xml version="1.0" encoding="UTF-8"?>
          <databaseChangeLog xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
                             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                             xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
                             http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.8.xsd">
              <changeSet id="1" author="test">
                  <createTable tableName="test_table">
                      <column name="id" type="int"/>
                  </createTable>
              </changeSet>
          </databaseChangeLog>
          EOF
          
          # Test updateSQL with relative path to generate SQL output file
          docker run --rm --env LIQUIBASE_LICENSE_KEY=${{ env.PRO_LICENSE_KEY }} -v $(pwd)/test-file-creation:/liquibase/changelog \
            liquibase/liquibase:${{ github.sha }} \
            updateSQL --changelogFile=test-changelog.xml --url=offline:postgresql --outputFile=generated-update.sql
          
          # Verify file was created in the mounted directory (not container root)
          if [ -f "test-file-creation/generated-update.sql" ]; then
            echo "✅ SUCCESS: File created in mounted directory with relative path"
            echo "File contents preview:"
            head -5 test-file-creation/generated-update.sql
          else
            echo "❌ FAIL: File not created in expected location"
            echo "Files in test directory:"
            ls -la test-file-creation/
            # Also check if the file was created in container root (wrong location)
            echo "Testing if file was created in wrong location..."
            WRONG_LOCATION=$(docker run --rm --env LIQUIBASE_LICENSE_KEY=${{ env.PRO_LICENSE_KEY }} -v $(pwd)/test-file-creation:/liquibase/changelog \
              liquibase/liquibase:${{ github.sha }} \
              sh -c "ls -la /liquibase/generated-update.sql 2>/dev/null || echo 'NOT_FOUND'")
            echo "Check for file in container root: $WRONG_LOCATION"
            exit 1
          fi
          
          # Cleanup
          rm -rf test-file-creation

      - name: Test CLI-Docker compatibility - Properties file resolution
        run: |
          echo "Testing properties file resolution with relative paths..."
          
          # Create test directory with properties file
          mkdir -p test-properties
          cat > test-properties/test.properties << EOF
          changelogFile=test-changelog.xml
          url=offline:postgresql
          driver=org.postgresql.Driver
          EOF
          
          cat > test-properties/test-changelog.xml << 'EOF'
          <?xml version="1.0" encoding="UTF-8"?>
          <databaseChangeLog xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
                             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                             xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
                             http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.8.xsd">
              <changeSet id="1" author="test">
                  <comment>Test changeset</comment>
                  <sql>SELECT 'Test';</sql>
              </changeSet>
          </databaseChangeLog>
          EOF
          
          # Test that properties file can be resolved with relative path
          RESULT=$(docker run --rm --env LIQUIBASE_LICENSE_KEY=${{ env.PRO_LICENSE_KEY }} -v $(pwd)/test-properties:/liquibase/changelog \
            liquibase/liquibase:${{ github.sha }} \
            --defaultsFile=test.properties validate 2>&1)
          
          echo "Validation result: $RESULT"
          
          if echo "$RESULT" | grep -q "No validation errors found"; then
            echo "✅ SUCCESS: Properties file resolved correctly with relative path"
          else
            echo "❌ FAIL: Properties file resolution failed"
            exit 1
          fi
          
          # Cleanup
          rm -rf test-properties

      - name: Test backward compatibility - No changelog directory
        run: |
          echo "Testing backward compatibility when no /liquibase/changelog is mounted..."
          
          # Test container works normally without changelog mount (backward compatibility)
          RESULT=$(docker run --rm --env LIQUIBASE_LICENSE_KEY=${{ env.PRO_LICENSE_KEY }} liquibase/liquibase:${{ github.sha }} --version)
          
          if echo "$RESULT" | grep -q "Liquibase Version"; then
            echo "✅ SUCCESS: Container works without changelog mount (backward compatible)"
          else
            echo "❌ FAIL: Container broken when no changelog directory mounted"
            exit 1
          fi

      - name: Test backward compatibility - Absolute paths still work
        run: |
          echo "Testing that absolute paths still work (backward compatibility)..."
          
          # Create test setup
          mkdir -p test-absolute-paths
          cat > test-absolute-paths/test-changelog.xml << 'EOF'
          <?xml version="1.0" encoding="UTF-8"?>
          <databaseChangeLog xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
                             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                             xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
                             http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.8.xsd">
              <changeSet id="1" author="test">
                  <sql>SELECT 'Test';</sql>
              </changeSet>
          </databaseChangeLog>
          EOF
          
          # Test with absolute path (old way should still work)
          RESULT=$(docker run --rm --env LIQUIBASE_LICENSE_KEY=${{ env.PRO_LICENSE_KEY }} -v $(pwd)/test-absolute-paths:/liquibase/changelog \
            liquibase/liquibase:${{ github.sha }} \
            validate --changelogFile=/liquibase/changelog/test-changelog.xml --url=offline:postgresql 2>&1)
          
          echo "Absolute path validation result: $RESULT"
          
          if echo "$RESULT" | grep -q "No validation errors found"; then
            echo "✅ SUCCESS: Absolute paths still work (backward compatible)"
          else
            echo "❌ FAIL: Absolute path compatibility broken"
            exit 1
          fi
          
          # Cleanup
          rm -rf test-absolute-paths

      - name: Test CLI-Docker compatibility - Complex scenario  
        run: |
          echo "Testing complex scenario with multiple relative paths..."
          
          # Create complex test structure
          mkdir -p test-complex/{changelog,lib}
          
          cat > test-complex/changelog/db.changelog-root.xml << 'EOF'
          <?xml version="1.0" encoding="UTF-8"?>
          <databaseChangeLog xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
                             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                             xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
                             http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.8.xsd">
              <include file="001-tables.xml" relativeToChangelogFile="true"/>
          </databaseChangeLog>
          EOF
          
          cat > test-complex/changelog/001-tables.xml << 'EOF'
          <?xml version="1.0" encoding="UTF-8"?>
          <databaseChangeLog xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
                             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                             xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
                             http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.8.xsd">
              <changeSet id="1" author="test">
                  <createTable tableName="test_table">
                      <column name="id" type="int"/>
                  </createTable>
              </changeSet>
          </databaseChangeLog>
          EOF
          
          cat > test-complex/app.properties << EOF
          changelogFile=db.changelog-root.xml  
          url=offline:postgresql
          driver=org.postgresql.Driver
          EOF
          
          # Test complex scenario with includes and relative paths
          RESULT=$(docker run --rm --env LIQUIBASE_LICENSE_KEY=${{ env.PRO_LICENSE_KEY }} -v $(pwd)/test-complex/changelog:/liquibase/changelog -v $(pwd)/test-complex:/liquibase/app \
            liquibase/liquibase:${{ github.sha }} \
            --defaultsFile=../app/app.properties validate 2>&1)
          
          echo "Complex validation result: $RESULT"  
          
          if echo "$RESULT" | grep -q "No validation errors found"; then
            echo "✅ SUCCESS: Complex relative path scenario works"
          else
            echo "❌ FAIL: Complex relative path scenario failed"
            exit 1
          fi
          
          # Cleanup
          rm -rf test-complex
